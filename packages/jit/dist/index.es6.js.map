{"version":3,"file":"index.es6.js","sources":["../src/attribute-parser.ts","../../../node_modules/tslib/tslib.es6.js","../src/instructions.ts","../src/binding-command.ts","../src/common.ts","../src/expression-parser.ts","../src/element-parser.ts","../src/semantic-model.ts","../src/template-compiler.ts","../src/configuration.ts"],"sourcesContent":["import { DI } from '@au-test/kernel';\nimport { Char } from './common';\n\nexport class AttrSyntax {\n  constructor(\n    public readonly rawName: string,\n    public readonly rawValue: string,\n    public readonly target: string,\n    public readonly command: string | null) { }\n}\n\nexport interface IAttributeParser {\n  parse(name: string, value: string): AttrSyntax;\n}\n\nexport const IAttributeParser = DI.createInterface<IAttributeParser>()\n  .withDefault(x => x.singleton(AttributeParser));\n\n/*@internal*/\nexport class AttributeParser implements IAttributeParser {\n  private cache: Record<string, [string, string]>;\n\n  constructor() {\n    this.cache = {};\n  }\n\n  public parse(name: string, value: string): AttrSyntax {\n    let target: string;\n    let command: string;\n    const existing = this.cache[name];\n    if (existing === undefined) {\n      let lastIndex = 0;\n      target = name;\n      for (let i = 0, ii = name.length; i < ii; ++i) {\n        if (name.charCodeAt(i) === Char.Dot) {\n          // set the targetName to only the part that comes before the first dot\n          if (name === target) {\n            target = name.slice(0, i);\n          }\n          lastIndex = i;\n        }\n      }\n      command = lastIndex > 0 ? name.slice(lastIndex + 1) : null;\n      this.cache[name] = [target, command];\n    } else {\n      target = existing[0];\n      command = existing[1];\n    }\n\n    return new AttrSyntax(name, value, target, command && command.length ? command : null);\n  }\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","import {\n  BindingMode,\n  DelegationStrategy,\n  ForOfStatement,\n  ICallBindingInstruction,\n  IHydrateAttributeInstruction,\n  IHydrateElementInstruction,\n  IHydrateTemplateController,\n  IInterpolationInstruction,\n  IIteratorBindingInstruction,\n  ILetBindingInstruction,\n  ILetElementInstruction,\n  IListenerBindingInstruction,\n  INode,\n  Interpolation,\n  IPropertyBindingInstruction,\n  IRefBindingInstruction,\n  IsBindingBehavior,\n  ISetPropertyInstruction,\n  IStylePropertyBindingInstruction,\n  ITargetedInstruction,\n  ITemplateSource,\n  ITextBindingInstruction,\n  TargetedInstruction,\n  TargetedInstructionType\n} from '@au-test/runtime';\n\n// tslint:disable:no-reserved-keywords\n// tslint:disable:no-any\nexport class TextBindingInstruction implements ITextBindingInstruction {\n  public type: TargetedInstructionType.textBinding = TargetedInstructionType.textBinding;\n  constructor(public srcOrExpr: string | Interpolation) {}\n}\nexport class InterpolationInstruction implements IInterpolationInstruction {\n  public type: TargetedInstructionType.interpolation = TargetedInstructionType.interpolation;\n  constructor(public srcOrExpr: string | Interpolation, public dest: string) {}\n}\nexport class OneTimeBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding = TargetedInstructionType.propertyBinding;\n  public oneTime: true = true;\n  public mode: BindingMode.oneTime = BindingMode.oneTime;\n  constructor(public srcOrExpr: string | IsBindingBehavior, public dest: string) {}\n}\nexport class ToViewBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding = TargetedInstructionType.propertyBinding;\n  public oneTime: false = false;\n  public mode: BindingMode.toView = BindingMode.toView;\n  constructor(public srcOrExpr: string | IsBindingBehavior, public dest: string) {}\n}\nexport class FromViewBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding = TargetedInstructionType.propertyBinding;\n  public oneTime: false = false;\n  public mode: BindingMode.fromView = BindingMode.fromView;\n  constructor(public srcOrExpr: string | IsBindingBehavior, public dest: string) {}\n}\nexport class TwoWayBindingInstruction implements IPropertyBindingInstruction {\n  public type: TargetedInstructionType.propertyBinding = TargetedInstructionType.propertyBinding;\n  public oneTime: false = false;\n  public mode: BindingMode.twoWay = BindingMode.twoWay;\n  constructor(public srcOrExpr: string | IsBindingBehavior, public dest: string) {}\n}\nexport class IteratorBindingInstruction implements IIteratorBindingInstruction {\n  public type: TargetedInstructionType.iteratorBinding = TargetedInstructionType.iteratorBinding;\n  constructor(public srcOrExpr: string | ForOfStatement, public dest: string) {}\n}\nexport class TriggerBindingInstruction implements IListenerBindingInstruction {\n  public type: TargetedInstructionType.listenerBinding = TargetedInstructionType.listenerBinding;\n  public strategy: DelegationStrategy.none = DelegationStrategy.none;\n  public preventDefault: true = true;\n  constructor(public srcOrExpr: string | IsBindingBehavior, public dest: string) {}\n}\nexport class DelegateBindingInstruction implements IListenerBindingInstruction {\n  public type: TargetedInstructionType.listenerBinding = TargetedInstructionType.listenerBinding;\n  public strategy: DelegationStrategy.bubbling = DelegationStrategy.bubbling;\n  public preventDefault: false = false;\n  constructor(public srcOrExpr: string | IsBindingBehavior, public dest: string) {}\n}\nexport class CaptureBindingInstruction implements IListenerBindingInstruction {\n  public type: TargetedInstructionType.listenerBinding = TargetedInstructionType.listenerBinding;\n  public strategy: DelegationStrategy.capturing = DelegationStrategy.capturing;\n  public preventDefault: false = false;\n  constructor(public srcOrExpr: string | IsBindingBehavior, public dest: string) {}\n}\nexport class CallBindingInstruction implements ICallBindingInstruction {\n  public type: TargetedInstructionType.callBinding = TargetedInstructionType.callBinding;\n  constructor(public srcOrExpr: string | IsBindingBehavior, public dest: string) {}\n}\nexport class RefBindingInstruction implements IRefBindingInstruction {\n  public type: TargetedInstructionType.refBinding = TargetedInstructionType.refBinding;\n  constructor(public srcOrExpr: string | IsBindingBehavior) {}\n}\nexport class StylePropertyBindingInstruction implements IStylePropertyBindingInstruction {\n  public type: TargetedInstructionType.stylePropertyBinding = TargetedInstructionType.stylePropertyBinding;\n  constructor(public srcOrExpr: string | IsBindingBehavior, public dest: string) {}\n}\nexport class SetPropertyInstruction implements ISetPropertyInstruction {\n  public type: TargetedInstructionType.setProperty = TargetedInstructionType.setProperty;\n  constructor(public value: any, public dest: string) {}\n}\nexport class SetAttributeInstruction implements ITargetedInstruction {\n  public type: TargetedInstructionType.setAttribute = TargetedInstructionType.setAttribute;\n  constructor(public value: any, public dest: string) {}\n}\nexport class HydrateElementInstruction implements IHydrateElementInstruction {\n  public type: TargetedInstructionType.hydrateElement = TargetedInstructionType.hydrateElement;\n  constructor(public res: any, public instructions: TargetedInstruction[], public parts?: Record<string, ITemplateSource>, public contentOverride?: INode) {}\n}\nexport class HydrateAttributeInstruction implements IHydrateAttributeInstruction {\n  public type: TargetedInstructionType.hydrateAttribute = TargetedInstructionType.hydrateAttribute;\n  constructor(public res: any, public instructions: TargetedInstruction[]) {}\n}\nexport class HydrateTemplateController implements IHydrateTemplateController {\n  public type: TargetedInstructionType.hydrateTemplateController = TargetedInstructionType.hydrateTemplateController;\n  constructor(public src: ITemplateSource, public res: any, public instructions: TargetedInstruction[], public link?: boolean) {}\n}\nexport class LetElementInstruction implements ILetElementInstruction {\n  public type: TargetedInstructionType.letElement = TargetedInstructionType.letElement;\n  constructor(public instructions: ILetBindingInstruction[], public toViewModel: boolean) {}\n}\nexport class LetBindingInstruction implements ILetBindingInstruction {\n  public type: TargetedInstructionType.letBinding = TargetedInstructionType.letBinding;\n  constructor(public srcOrExpr: string | IsBindingBehavior | Interpolation, public dest: string) {}\n}\n","import { Constructable, IContainer, Registration, Writable } from '@au-test/kernel';\nimport { BindingType, IExpressionParser, IResourceKind, IResourceType, ITemplateSource, TargetedInstruction } from '@au-test/runtime';\nimport {\n  CallBindingInstruction,\n  CaptureBindingInstruction,\n  DelegateBindingInstruction,\n  FromViewBindingInstruction,\n  HydrateTemplateController,\n  IteratorBindingInstruction,\n  OneTimeBindingInstruction,\n  SetPropertyInstruction,\n  ToViewBindingInstruction,\n  TriggerBindingInstruction,\n  TwoWayBindingInstruction\n} from './instructions';\nimport { IAttributeSymbol } from './semantic-model';\n\nexport interface IBindingCommandSource {\n  name: string;\n}\n\nexport interface IBindingCommand {\n  compile($symbol: IAttributeSymbol): TargetedInstruction;\n  handles($symbol: IAttributeSymbol): boolean;\n}\n\nexport type IBindingCommandType = IResourceType<IBindingCommandSource, IBindingCommand>;\n\nexport function bindingCommand(nameOrSource: string | IBindingCommandSource) {\n  return function<T extends Constructable>(target: T) {\n    return BindingCommandResource.define(nameOrSource, target);\n  };\n}\n\nexport const BindingCommandResource: IResourceKind<IBindingCommandSource, IBindingCommandType> = {\n  name: 'binding-command',\n\n  keyFrom(name: string): string {\n    return `${this.name}:${name}`;\n  },\n\n  isType<T extends Constructable>(type: T): type is T & IBindingCommandType {\n    return (type as any).kind === this;\n  },\n\n  define<T extends Constructable>(nameOrSource: string | IBindingCommandSource, ctor: T): T & IBindingCommandType {\n    const description = typeof nameOrSource === 'string' ? { name: nameOrSource, target: null } : nameOrSource;\n    const Type: T & IBindingCommandType = ctor as any;\n\n    (Type as Writable<IBindingCommandType>).kind = BindingCommandResource;\n    (Type as Writable<IBindingCommandType>).description = description;\n    Type.register = function(container: IContainer) {\n      container.register(Registration.singleton(Type.kind.keyFrom(description.name), Type));\n    };\n\n    const proto = Type.prototype;\n\n    proto.handles = proto.handles || defaultHandles;\n\n    return Type;\n  }\n};\n\nfunction defaultHandles(this: IBindingCommand, $symbol: IAttributeSymbol): boolean {\n  return !$symbol.isTemplateController;\n}\n\nexport interface OneTimeBindingCommand extends IBindingCommand {}\n\n@bindingCommand('one-time')\nexport class OneTimeBindingCommand implements IBindingCommand {\n  public static inject: Function[] = [IExpressionParser];\n  constructor(private parser: IExpressionParser) {}\n  public compile($symbol: IAttributeSymbol): TargetedInstruction {\n    return new OneTimeBindingInstruction(this.parser.parse($symbol.rawValue, BindingType.OneTimeCommand), $symbol.dest);\n  }\n}\n\nexport interface ToViewBindingCommand extends IBindingCommand {}\n\n@bindingCommand('to-view')\nexport class ToViewBindingCommand implements IBindingCommand {\n  public static inject: Function[] = [IExpressionParser];\n  constructor(private parser: IExpressionParser) {}\n  public compile($symbol: IAttributeSymbol): TargetedInstruction {\n    return new ToViewBindingInstruction(this.parser.parse($symbol.rawValue, BindingType.ToViewCommand), $symbol.dest);\n  }\n}\n\nexport interface FromViewBindingCommand extends IBindingCommand {}\n\n@bindingCommand('from-view')\nexport class FromViewBindingCommand implements IBindingCommand {\n  public static inject: Function[] = [IExpressionParser];\n  constructor(private parser: IExpressionParser) {}\n  public compile($symbol: IAttributeSymbol): TargetedInstruction {\n    return new FromViewBindingInstruction(this.parser.parse($symbol.rawValue, BindingType.FromViewCommand), $symbol.dest);\n  }\n}\n\nexport interface TwoWayBindingCommand extends IBindingCommand {}\n\n@bindingCommand('two-way')\nexport class TwoWayBindingCommand implements IBindingCommand {\n  public static inject: Function[] = [IExpressionParser];\n  constructor(private parser: IExpressionParser) {}\n  public compile($symbol: IAttributeSymbol): TargetedInstruction {\n    return new TwoWayBindingInstruction(this.parser.parse($symbol.rawValue, BindingType.TwoWayCommand), $symbol.dest);\n  }\n}\n\n// Not bothering to throw on non-existing modes, should never happen anyway.\n// Keeping all array elements of the same type for better optimizeability.\nconst compileMode = ['', '$1', '$2', '', '$4', '', '$6'];\n\nexport interface DefaultBindingCommand extends IBindingCommand {}\n\n@bindingCommand('bind')\nexport class DefaultBindingCommand implements IBindingCommand {\n  public static inject: Function[] = [IExpressionParser];\n  public $1: typeof OneTimeBindingCommand.prototype.compile;\n  public $2: typeof ToViewBindingCommand.prototype.compile;\n  public $4: typeof FromViewBindingCommand.prototype.compile;\n  public $6: typeof TwoWayBindingCommand.prototype.compile;\n\n  constructor(private parser: IExpressionParser) {}\n\n  public compile($symbol: IAttributeSymbol): TargetedInstruction {\n    return this[compileMode[$symbol.mode]]($symbol);\n  }\n}\n\nDefaultBindingCommand.prototype.$1 = OneTimeBindingCommand.prototype.compile;\nDefaultBindingCommand.prototype.$2 = ToViewBindingCommand.prototype.compile;\nDefaultBindingCommand.prototype.$4 = FromViewBindingCommand.prototype.compile;\nDefaultBindingCommand.prototype.$6 = TwoWayBindingCommand.prototype.compile;\n\nexport interface TriggerBindingCommand extends IBindingCommand {}\n\n@bindingCommand('trigger')\nexport class TriggerBindingCommand implements IBindingCommand {\n  public static inject: Function[] = [IExpressionParser];\n  constructor(private parser: IExpressionParser) {}\n  public compile($symbol: IAttributeSymbol): TargetedInstruction {\n    return new TriggerBindingInstruction(this.parser.parse($symbol.rawValue, BindingType.TriggerCommand), $symbol.dest);\n  }\n}\n\nexport interface DelegateBindingCommand extends IBindingCommand {}\n\n@bindingCommand('delegate')\nexport class DelegateBindingCommand implements IBindingCommand {\n  public static inject: Function[] = [IExpressionParser];\n  constructor(private parser: IExpressionParser) {}\n  public compile($symbol: IAttributeSymbol): TargetedInstruction {\n    return new DelegateBindingInstruction(this.parser.parse($symbol.rawValue, BindingType.DelegateCommand), $symbol.dest);\n  }\n}\n\nexport interface CaptureBindingCommand extends IBindingCommand {}\n\n@bindingCommand('capture')\nexport class CaptureBindingCommand implements IBindingCommand {\n  public static inject: Function[] = [IExpressionParser];\n  constructor(private parser: IExpressionParser) {}\n  public compile($symbol: IAttributeSymbol): TargetedInstruction {\n    return new CaptureBindingInstruction(this.parser.parse($symbol.rawValue, BindingType.CaptureCommand), $symbol.dest);\n  }\n}\n\nexport interface CallBindingCommand extends IBindingCommand {}\n\n@bindingCommand('call')\nexport class CallBindingCommand implements IBindingCommand {\n  public static inject: Function[] = [IExpressionParser];\n  constructor(private parser: IExpressionParser) {}\n  public compile($symbol: IAttributeSymbol): TargetedInstruction {\n    return new CallBindingInstruction(this.parser.parse($symbol.rawValue, BindingType.CallCommand), $symbol.dest);\n  }\n}\n\n@bindingCommand('for')\nexport class ForBindingCommand implements IBindingCommand {\n  public static inject: Function[] = [IExpressionParser];\n  constructor(private parser: IExpressionParser) {}\n  public compile($symbol: IAttributeSymbol): TargetedInstruction {\n    const src: ITemplateSource = {\n      name: 'repeat',\n      templateOrNode: $symbol.$element.node,\n      instructions: []\n    };\n    return new HydrateTemplateController(src, 'repeat', [\n      new IteratorBindingInstruction(this.parser.parse($symbol.rawValue, BindingType.ForCommand), 'items'),\n      new SetPropertyInstruction('item', 'local')\n    // tslint:disable-next-line:align\n    ], false);\n  }\n\n  public handles($symbol: IAttributeSymbol): boolean {\n    return $symbol.target === 'repeat';\n  }\n}\n","/*@internal*/\nexport function unescapeCode(code: number): number {\n  switch (code) {\n    case Char.LowerB: return Char.Backspace;\n    case Char.LowerT: return Char.Tab;\n    case Char.LowerN: return Char.LineFeed;\n    case Char.LowerV: return Char.VerticalTab;\n    case Char.LowerF: return Char.FormFeed;\n    case Char.LowerR: return Char.CarriageReturn;\n    case Char.DoubleQuote: return Char.DoubleQuote;\n    case Char.SingleQuote: return Char.SingleQuote;\n    case Char.Backslash: return Char.Backslash;\n    default: return code;\n  }\n}\n\n/*@internal*/\nexport const enum Access {\n  Reset                   = 0b0000000000000,\n  Ancestor                = 0b0000111111111,\n  This                    = 0b0001000000000,\n  Scope                   = 0b0010000000000,\n  Member                  = 0b0100000000000,\n  Keyed                   = 0b1000000000000\n}\n/*@internal*/\nexport const enum Precedence {\n  Variadic                = 0b000111101,\n  Assign                  = 0b000111110,\n  Conditional             = 0b000111111,\n  LogicalOR               = 0b001000000,\n  LogicalAND              = 0b010000000,\n  Equality                = 0b011000000,\n  Relational              = 0b100000000,\n  Additive                = 0b101000000,\n  Multiplicative          = 0b110000000,\n  Binary                  = 0b111000000,\n  LeftHandSide            = 0b111000001,\n  Primary                 = 0b111000010,\n  Unary                   = 0b111000011,\n}\n/*@internal*/\nexport const enum Token {\n  EOF                     = 0b110000000000_000_000000,\n  ExpressionTerminal      = 0b100000000000_000_000000,\n  AccessScopeTerminal     = 0b010000000000_000_000000,\n  ClosingToken            = 0b001000000000_000_000000,\n  OpeningToken            = 0b000100000000_000_000000,\n  BinaryOp                = 0b000010000000_000_000000,\n  UnaryOp                 = 0b000001000000_000_000000,\n  LeftHandSide            = 0b000000100000_000_000000,\n  StringOrNumericLiteral  = 0b000000011000_000_000000,\n  NumericLiteral          = 0b000000010000_000_000000,\n  StringLiteral           = 0b000000001000_000_000000,\n  IdentifierName          = 0b000000000110_000_000000,\n  Keyword                 = 0b000000000100_000_000000,\n  Identifier              = 0b000000000010_000_000000,\n  Contextual              = 0b000000000001_000_000000,\n  Precedence              = 0b000000000000_111_000000,\n  Type                    = 0b000000000000_000_111111,\n  FalseKeyword            = 0b000000000100_000_000000,\n  TrueKeyword             = 0b000000000100_000_000001,\n  NullKeyword             = 0b000000000100_000_000010,\n  UndefinedKeyword        = 0b000000000100_000_000011,\n  ThisScope               = 0b000000000110_000_000100,\n  ParentScope             = 0b000000000110_000_000101,\n  OpenParen               = 0b010100100000_000_000110,\n  OpenBrace               = 0b000100000000_000_000111,\n  Dot                     = 0b000000100000_000_001000,\n  CloseBrace              = 0b111000000000_000_001001,\n  CloseParen              = 0b111000000000_000_001010,\n  Comma                   = 0b110000000000_000_001011,\n  OpenBracket             = 0b010100100000_000_001100,\n  CloseBracket            = 0b111000000000_000_001101,\n  Colon                   = 0b110000000000_000_001110,\n  Question                = 0b110000000000_000_001111,\n  Ampersand               = 0b110000000000_000_010000,\n  Bar                     = 0b110000000000_000_010011,\n  BarBar                  = 0b110010000000_010_010100,\n  AmpersandAmpersand      = 0b110010000000_011_010101,\n  EqualsEquals            = 0b110010000000_100_010110,\n  ExclamationEquals       = 0b110010000000_100_010111,\n  EqualsEqualsEquals      = 0b110010000000_100_011000,\n  ExclamationEqualsEquals = 0b110010000000_100_011001,\n  LessThan                = 0b110010000000_101_011010,\n  GreaterThan             = 0b110010000000_101_011011,\n  LessThanEquals          = 0b110010000000_101_011100,\n  GreaterThanEquals       = 0b110010000000_101_011101,\n  InKeyword               = 0b110010000100_101_011110,\n  InstanceOfKeyword       = 0b110010000100_101_011111,\n  Plus                    = 0b010011000000_110_100000,\n  Minus                   = 0b010011000000_110_100001,\n  TypeofKeyword           = 0b000001000100_000_100010,\n  VoidKeyword             = 0b000001000100_000_100011,\n  Asterisk                = 0b110010000000_111_100100,\n  Percent                 = 0b110010000000_111_100101,\n  Slash                   = 0b110010000000_111_100110,\n  Equals                  = 0b100000000000_000_100111,\n  Exclamation             = 0b000001000000_000_101000,\n  TemplateTail            = 0b010000100000_000_101001,\n  TemplateContinuation    = 0b010000100000_000_101010,\n  OfKeyword               = 0b100000000101_000_101011\n}\n\n/*@internal*/\nexport const enum Char {\n  Null           = 0x00,\n  Backspace      = 0x08,\n  Tab            = 0x09,\n  LineFeed       = 0x0A,\n  VerticalTab    = 0x0B,\n  FormFeed       = 0x0C,\n  CarriageReturn = 0x0D,\n  Space          = 0x20,\n  Exclamation    = 0x21,\n  DoubleQuote    = 0x22,\n  Dollar         = 0x24,\n  Percent        = 0x25,\n  Ampersand      = 0x26,\n  SingleQuote    = 0x27,\n  OpenParen      = 0x28,\n  CloseParen     = 0x29,\n  Asterisk       = 0x2A,\n  Plus           = 0x2B,\n  Comma          = 0x2C,\n  Minus          = 0x2D,\n  Dot            = 0x2E,\n  Slash          = 0x2F,\n  Semicolon      = 0x3B,\n  Backtick       = 0x60,\n  OpenBracket    = 0x5B,\n  Backslash      = 0x5C,\n  CloseBracket   = 0x5D,\n  Caret          = 0x5E,\n  Underscore     = 0x5F,\n  OpenBrace      = 0x7B,\n  Bar            = 0x7C,\n  CloseBrace     = 0x7D,\n  Colon          = 0x3A,\n  LessThan       = 0x3C,\n  Equals         = 0x3D,\n  GreaterThan    = 0x3E,\n  Question       = 0x3F,\n\n  Zero   = 0x30,\n  One    = 0x31,\n  Two    = 0x32,\n  Three  = 0x33,\n  Four   = 0x34,\n  Five   = 0x35,\n  Six    = 0x36,\n  Seven  = 0x37,\n  Eight  = 0x38,\n  Nine   = 0x39,\n\n  UpperA = 0x41,\n  UpperB = 0x42,\n  UpperC = 0x43,\n  UpperD = 0x44,\n  UpperE = 0x45,\n  UpperF = 0x46,\n  UpperG = 0x47,\n  UpperH = 0x48,\n  UpperI = 0x49,\n  UpperJ = 0x4A,\n  UpperK = 0x4B,\n  UpperL = 0x4C,\n  UpperM = 0x4D,\n  UpperN = 0x4E,\n  UpperO = 0x4F,\n  UpperP = 0x50,\n  UpperQ = 0x51,\n  UpperR = 0x52,\n  UpperS = 0x53,\n  UpperT = 0x54,\n  UpperU = 0x55,\n  UpperV = 0x56,\n  UpperW = 0x57,\n  UpperX = 0x58,\n  UpperY = 0x59,\n  UpperZ = 0x5A,\n\n  LowerA  = 0x61,\n  LowerB  = 0x62,\n  LowerC  = 0x63,\n  LowerD  = 0x64,\n  LowerE  = 0x65,\n  LowerF  = 0x66,\n  LowerG  = 0x67,\n  LowerH  = 0x68,\n  LowerI  = 0x69,\n  LowerJ  = 0x6A,\n  LowerK  = 0x6B,\n  LowerL  = 0x6C,\n  LowerM  = 0x6D,\n  LowerN  = 0x6E,\n  LowerO  = 0x6F,\n  LowerP  = 0x70,\n  LowerQ  = 0x71,\n  LowerR  = 0x72,\n  LowerS  = 0x73,\n  LowerT  = 0x74,\n  LowerU  = 0x75,\n  LowerV  = 0x76,\n  LowerW  = 0x77,\n  LowerX  = 0x78,\n  LowerY  = 0x79,\n  LowerZ  = 0x7A\n}\n","// tslint:disable:no-non-null-assertion\nimport { IContainer, IRegistry, Reporter } from '@au-test/kernel';\nimport {\n  AccessKeyed, AccessMember, AccessScope, AccessThis,\n  ArrayBindingPattern, ArrayLiteral, Assign, Binary,\n  BinaryOperator, BindingBehavior, BindingIdentifier,\n  BindingIdentifierOrPattern, BindingType, CallFunction,\n  CallMember, CallScope, Conditional, ExpressionKind, ForOfStatement,\n  IExpression, IExpressionParser, Interpolation, IsAssign, IsAssignable,\n  IsBinary, IsBindingBehavior, IsConditional,\n  IsExpressionOrStatement, IsLeftHandSide, IsPrimary, IsUnary,\n  IsValueConverter, ObjectBindingPattern, ObjectLiteral, PrimitiveLiteral, TaggedTemplate, Template, Unary, UnaryOperator, ValueConverter\n} from '@au-test/runtime';\nimport { Access, Char, Precedence, Token, unescapeCode } from './common';\n\nexport const ParserRegistration: IRegistry = {\n  register(container: IContainer): void {\n    container.registerTransformer(IExpressionParser, parser => {\n      parser['parseCore'] = parseCore;\n      return parser;\n    });\n  }\n};\n\nconst $false = PrimitiveLiteral.$false;\nconst $true = PrimitiveLiteral.$true;\nconst $null = PrimitiveLiteral.$null;\nconst $undefined = PrimitiveLiteral.$undefined;\nconst $this = AccessThis.$this;\nconst $parent = AccessThis.$parent;\n\n/*@internal*/\nexport class ParserState {\n  public index: number;\n  public startIndex: number;\n  public input: string;\n  public lastIndex: number;\n  public length: number;\n  public currentToken: Token;\n  public tokenValue: string | number;\n  public currentChar: number;\n  public assignable: boolean;\n  public get tokenRaw(): string {\n    return this.input.slice(this.startIndex, this.index);\n  }\n\n  constructor(input: string) {\n    this.index = 0;\n    this.startIndex = 0;\n    this.lastIndex = 0;\n    this.input = input;\n    this.length = input.length;\n    this.currentToken = Token.EOF;\n    this.tokenValue = '';\n    this.currentChar = input.charCodeAt(0);\n    this.assignable = true;\n  }\n}\n\nconst $state = new ParserState('');\n\nconst enum SyntaxError {\n  InvalidExpressionStart = 100,\n  UnconsumedToken = 101,\n  DoubleDot = 102,\n  InvalidMemberExpression = 103,\n  UnexpectedEndOfExpression = 104,\n  ExpectedIdentifier = 105,\n  InvalidForDeclaration = 106,\n  InvalidObjectLiteralPropertyDefinition = 107,\n  UnterminatedQuote = 108,\n  UnterminatedTemplate = 109,\n  MissingExpectedToken = 110,\n  UnexpectedCharacter = 111,\n  MissingValueConverter = 112,\n  MissingBindingBehavior = 113\n}\n\nconst enum SemanticError {\n  NotAssignable = 150,\n  UnexpectedForOf = 151\n}\n\n/*@internal*/\nexport function parseCore(input: string, bindingType?: BindingType): IExpression {\n  $state.input = input;\n  $state.length = input.length;\n  $state.index = 0;\n  $state.currentChar = input.charCodeAt(0);\n  return parse($state, Access.Reset, Precedence.Variadic, bindingType === undefined ? BindingType.BindCommand : bindingType);\n}\n\n/*@internal*/\nexport function parse<TPrec extends Precedence, TType extends BindingType>(state: ParserState, access: Access, minPrecedence: TPrec, bindingType: TType):\n  TPrec extends Precedence.Unary ? IsUnary :\n  TPrec extends Precedence.Binary ? IsBinary :\n  TPrec extends Precedence.LeftHandSide ? IsLeftHandSide :\n  TPrec extends Precedence.Assign ? IsAssign :\n  TPrec extends Precedence.Conditional ? IsConditional :\n  TPrec extends Precedence.Primary ? IsPrimary :\n  TPrec extends Precedence.Multiplicative ? IsBinary :\n  TPrec extends Precedence.Additive ? IsBinary :\n  TPrec extends Precedence.Relational ? IsBinary :\n  TPrec extends Precedence.Equality ? IsBinary :\n  TPrec extends Precedence.LogicalAND ? IsBinary :\n  TPrec extends Precedence.LogicalOR ? IsBinary :\n  TPrec extends Precedence.Variadic ?\n    TType extends BindingType.Interpolation ? Interpolation :\n    TType extends BindingType.ForCommand ? ForOfStatement :\n    never : never {\n\n  if (state.index === 0) {\n    if ((bindingType & BindingType.Interpolation) > 0) {\n      // tslint:disable-next-line:no-any\n      return parseInterpolation(state) as any;\n    }\n    nextToken(state);\n    if ((state.currentToken & Token.ExpressionTerminal) > 0) {\n      throw Reporter.error(SyntaxError.InvalidExpressionStart, { state });\n    }\n  }\n\n  state.assignable = Precedence.Binary > minPrecedence;\n  let result = undefined as IsExpressionOrStatement;\n\n  if ((state.currentToken & Token.UnaryOp) > 0) {\n    /** parseUnaryExpression\n     * https://tc39.github.io/ecma262/#sec-unary-operators\n     *\n     * UnaryExpression :\n     *   1. LeftHandSideExpression\n     *   2. void UnaryExpression\n     *   3. typeof UnaryExpression\n     *   4. + UnaryExpression\n     *   5. - UnaryExpression\n     *   6. ! UnaryExpression\n     *\n     * IsValidAssignmentTarget\n     *   2,3,4,5,6 = false\n     *   1 = see parseLeftHandSideExpression\n     *\n     * Note: technically we should throw on ++ / -- / +++ / ---, but there's nothing to gain from that\n     */\n    const op = TokenValues[state.currentToken & Token.Type] as UnaryOperator;\n    nextToken(state);\n    result = new Unary(op, parse(state, access, Precedence.LeftHandSide, bindingType) as IsLeftHandSide);\n    state.assignable = false;\n  } else {\n    /** parsePrimaryExpression\n     * https://tc39.github.io/ecma262/#sec-primary-expression\n     *\n     * PrimaryExpression :\n     *   1. this\n     *   2. IdentifierName\n     *   3. Literal\n     *   4. ArrayLiteral\n     *   5. ObjectLiteral\n     *   6. TemplateLiteral\n     *   7. ParenthesizedExpression\n     *\n     * Literal :\n     *    NullLiteral\n     *    BooleanLiteral\n     *    NumericLiteral\n     *    StringLiteral\n     *\n     * ParenthesizedExpression :\n     *   ( AssignmentExpression )\n     *\n     * IsValidAssignmentTarget\n     *   1,3,4,5,6,7 = false\n     *   2 = true\n     */\n    primary: switch (state.currentToken) {\n    case Token.ParentScope: // $parent\n      state.assignable = false;\n      do {\n        nextToken(state);\n        access++; // ancestor\n        if (consumeOpt(state, Token.Dot)) {\n          if (state!.currentToken === Token.Dot) {\n            throw Reporter.error(SyntaxError.DoubleDot, { state });\n          } else if (state!.currentToken === Token.EOF) {\n            throw Reporter.error(SyntaxError.ExpectedIdentifier, { state });\n          }\n          continue;\n        } else if ((state.currentToken & Token.AccessScopeTerminal) > 0) {\n          const ancestor = access & Access.Ancestor;\n          result = ancestor === 0 ? $this : ancestor === 1 ? $parent : new AccessThis(ancestor);\n          access = Access.This;\n          break primary;\n        } else {\n          throw Reporter.error(SyntaxError.InvalidMemberExpression, { state });\n        }\n      } while (state.currentToken === Token.ParentScope);\n    // falls through\n    case Token.Identifier: // identifier\n      if ((bindingType & BindingType.IsIterator) > 0) {\n        result = new BindingIdentifier(<string>state.tokenValue);\n      } else {\n        result = new AccessScope(<string>state.tokenValue, access & Access.Ancestor);\n        access = Access.Scope;\n      }\n      state.assignable = true;\n      nextToken(state);\n      break;\n    case Token.ThisScope: // $this\n      state.assignable = false;\n      nextToken(state);\n      result = $this;\n      access = Access.This;\n      break;\n    case Token.OpenParen: // parenthesized expression\n      nextToken(state);\n      result = parse(state, Access.Reset, Precedence.Assign, bindingType);\n      consume(state, Token.CloseParen);\n      access = Access.Reset;\n      break;\n    case Token.OpenBracket:\n      result = parseArrayLiteralExpression(state, access, bindingType);\n      access = Access.Reset;\n      break;\n    case Token.OpenBrace:\n      result = parseObjectLiteralExpression(state, bindingType);\n      access = Access.Reset;\n      break;\n    case Token.TemplateTail:\n      result = new Template([<string>state.tokenValue]);\n      state.assignable = false;\n      nextToken(state);\n      access = Access.Reset;\n      break;\n    case Token.TemplateContinuation:\n      result = parseTemplate(state, access, bindingType, result as IsLeftHandSide, false);\n      access = Access.Reset;\n      break;\n    case Token.StringLiteral:\n    case Token.NumericLiteral:\n      result = new PrimitiveLiteral(state.tokenValue);\n      state.assignable = false;\n      nextToken(state);\n      access = Access.Reset;\n      break;\n    case Token.NullKeyword:\n    case Token.UndefinedKeyword:\n    case Token.TrueKeyword:\n    case Token.FalseKeyword:\n      result = TokenValues[state.currentToken & Token.Type] as PrimitiveLiteral;\n      state.assignable = false;\n      nextToken(state);\n      access = Access.Reset;\n      break;\n    default:\n      if (state.index >= state.length) {\n        throw Reporter.error(SyntaxError.UnexpectedEndOfExpression, { state });\n      } else {\n        throw Reporter.error(SyntaxError.UnconsumedToken, { state });\n      }\n    }\n\n    if ((bindingType & BindingType.IsIterator) > 0) {\n      // tslint:disable-next-line:no-any\n      return parseForOfStatement(state, result as BindingIdentifierOrPattern) as any;\n    }\n    // tslint:disable-next-line:no-any\n    if (Precedence.LeftHandSide < minPrecedence) return result as any;\n\n    /** parseMemberExpression (Token.Dot, Token.OpenBracket, Token.TemplateContinuation)\n     * MemberExpression :\n     *   1. PrimaryExpression\n     *   2. MemberExpression [ AssignmentExpression ]\n     *   3. MemberExpression . IdentifierName\n     *   4. MemberExpression TemplateLiteral\n     *\n     * IsValidAssignmentTarget\n     *   1,4 = false\n     *   2,3 = true\n     *\n     *\n     * parseCallExpression (Token.OpenParen)\n     * CallExpression :\n     *   1. MemberExpression Arguments\n     *   2. CallExpression Arguments\n     *   3. CallExpression [ AssignmentExpression ]\n     *   4. CallExpression . IdentifierName\n     *   5. CallExpression TemplateLiteral\n     *\n     * IsValidAssignmentTarget\n     *   1,2,5 = false\n     *   3,4 = true\n     */\n    let name = state.tokenValue as string;\n    while ((state.currentToken & Token.LeftHandSide) > 0) {\n      switch (state!.currentToken) {\n        case Token.Dot:\n          state.assignable = true;\n          nextToken(state);\n          if ((state.currentToken & Token.IdentifierName) === 0) {\n            throw Reporter.error(SyntaxError.ExpectedIdentifier, { state });\n          }\n          name = state.tokenValue as string;\n          nextToken(state);\n          // Change $This to $Scope, change $Scope to $Member, keep $Member as-is, change $Keyed to $Member, disregard other flags\n          access = ((access & (Access.This | Access.Scope)) << 1) | (access & Access.Member) | ((access & Access.Keyed) >> 1);\n          if (state!.currentToken === Token.OpenParen) {\n            if (access === Access.Reset) { // if the left hand side is a literal, make sure we parse a CallMember\n              access = Access.Member;\n            }\n            continue;\n          }\n          if ((access & Access.Scope) > 0) {\n            result = new AccessScope(name, (result as AccessScope | AccessThis).ancestor);\n          } else { // if it's not $Scope, it's $Member\n            result = new AccessMember(result as IsLeftHandSide, name);\n          }\n          continue;\n        case Token.OpenBracket:\n          state.assignable = true;\n          nextToken(state);\n          access = Access.Keyed;\n          result = new AccessKeyed(result as IsLeftHandSide, parse(state, Access.Reset, Precedence.Assign, bindingType));\n          consume(state, Token.CloseBracket);\n          break;\n        case Token.OpenParen:\n          state.assignable = false;\n          nextToken(state);\n          const args = new Array<IsAssign>();\n          while (state!.currentToken !== Token.CloseParen) {\n            args.push(parse(state, Access.Reset, Precedence.Assign, bindingType));\n            if (!consumeOpt(state, Token.Comma)) {\n              break;\n            }\n          }\n          consume(state, Token.CloseParen);\n          if ((access & Access.Scope) > 0) {\n            result = new CallScope(name, args, (result as AccessScope | AccessThis).ancestor);\n          } else if ((access & Access.Member) > 0) {\n            result = new CallMember(result as IsLeftHandSide, name, args);\n          } else {\n            result = new CallFunction(result as IsLeftHandSide, args);\n          }\n          access = 0;\n          break;\n        case Token.TemplateTail:\n          state.assignable = false;\n          const strings = [<string>state.tokenValue];\n          result = new TaggedTemplate(strings, strings, result as IsLeftHandSide);\n          nextToken(state);\n          break;\n        case Token.TemplateContinuation:\n          result = parseTemplate(state, access, bindingType, result as IsLeftHandSide, true);\n        default:\n      }\n    }\n  }\n\n  // tslint:disable-next-line:no-any\n  if (Precedence.Binary < minPrecedence) return result as any;\n\n  /** parseBinaryExpression\n   * https://tc39.github.io/ecma262/#sec-multiplicative-operators\n   *\n   * MultiplicativeExpression : (local precedence 6)\n   *   UnaryExpression\n   *   MultiplicativeExpression * / % UnaryExpression\n   *\n   * AdditiveExpression : (local precedence 5)\n   *   MultiplicativeExpression\n   *   AdditiveExpression + - MultiplicativeExpression\n   *\n   * RelationalExpression : (local precedence 4)\n   *   AdditiveExpression\n   *   RelationalExpression < > <= >= instanceof in AdditiveExpression\n   *\n   * EqualityExpression : (local precedence 3)\n   *   RelationalExpression\n   *   EqualityExpression == != === !== RelationalExpression\n   *\n   * LogicalANDExpression : (local precedence 2)\n   *   EqualityExpression\n   *   LogicalANDExpression && EqualityExpression\n   *\n   * LogicalORExpression : (local precedence 1)\n   *   LogicalANDExpression\n   *   LogicalORExpression || LogicalANDExpression\n   */\n  while ((state.currentToken & Token.BinaryOp) > 0) {\n    const opToken = state.currentToken;\n    if ((opToken & Token.Precedence) <= minPrecedence) {\n      break;\n    }\n    nextToken(state);\n    result = new Binary(TokenValues[opToken & Token.Type] as BinaryOperator, result as IsBinary, parse(state, access, opToken & Token.Precedence, bindingType));\n    state.assignable = false;\n  }\n  // tslint:disable-next-line:no-any\n  if (Precedence.Conditional < minPrecedence) return result as any;\n\n  /**\n   * parseConditionalExpression\n   * https://tc39.github.io/ecma262/#prod-ConditionalExpression\n   *\n   * ConditionalExpression :\n   *   1. BinaryExpression\n   *   2. BinaryExpression ? AssignmentExpression : AssignmentExpression\n   *\n   * IsValidAssignmentTarget\n   *   1,2 = false\n   */\n\n  if (consumeOpt(state, Token.Question)) {\n    const yes = parse(state, access, Precedence.Assign, bindingType);\n    consume(state, Token.Colon);\n    result = new Conditional(result as IsBinary, yes, parse(state, access, Precedence.Assign, bindingType));\n    state.assignable = false;\n  }\n  // tslint:disable-next-line:no-any\n  if (Precedence.Assign < minPrecedence) return result as any;\n\n  /** parseAssignmentExpression\n   * https://tc39.github.io/ecma262/#prod-AssignmentExpression\n   * Note: AssignmentExpression here is equivalent to ES Expression because we don't parse the comma operator\n   *\n   * AssignmentExpression :\n   *   1. ConditionalExpression\n   *   2. LeftHandSideExpression = AssignmentExpression\n   *\n   * IsValidAssignmentTarget\n   *   1,2 = false\n   */\n  if (consumeOpt(state, Token.Equals)) {\n    if (!state.assignable) {\n      throw Reporter.error(SemanticError.NotAssignable, { state });\n    }\n    result = new Assign(result as IsAssignable, parse(state, access, Precedence.Assign, bindingType));\n  }\n  // tslint:disable-next-line:no-any\n  if (Precedence.Variadic < minPrecedence) return result as any;\n\n  /** parseValueConverter\n   */\n  while (consumeOpt(state, Token.Bar)) {\n    if (state.currentToken === Token.EOF) {\n      throw Reporter.error(112);\n    }\n    const name = state.tokenValue as string;\n    nextToken(state);\n    const args = new Array<IsAssign>();\n    while (consumeOpt(state, Token.Colon)) {\n      args.push(parse(state, access, Precedence.Assign, bindingType));\n    }\n    result = new ValueConverter(result as IsValueConverter, name, args);\n  }\n\n  /** parseBindingBehavior\n   */\n  while (consumeOpt(state, Token.Ampersand)) {\n    if (state.currentToken === Token.EOF) {\n      throw Reporter.error(113);\n    }\n    const name = state.tokenValue as string;\n    nextToken(state);\n    const args = new Array<IsAssign>();\n    while (consumeOpt(state, Token.Colon)) {\n      args.push(parse(state, access, Precedence.Assign, bindingType));\n    }\n    result = new BindingBehavior(result as IsBindingBehavior, name, args);\n  }\n  if (state.currentToken !== Token.EOF) {\n    if ((bindingType & BindingType.Interpolation) > 0) {\n      // tslint:disable-next-line:no-any\n      return result as any;\n    }\n    if (state.tokenRaw === 'of') {\n      throw Reporter.error(SemanticError.UnexpectedForOf, { state });\n    }\n    throw Reporter.error(SyntaxError.UnconsumedToken, { state });\n  }\n  // tslint:disable-next-line:no-any\n  return result as any;\n}\n\n/**\n * parseArrayLiteralExpression\n * https://tc39.github.io/ecma262/#prod-ArrayLiteral\n *\n * ArrayLiteral :\n *   [ Elision(opt) ]\n *   [ ElementList ]\n *   [ ElementList, Elision(opt) ]\n *\n * ElementList :\n *   Elision(opt) AssignmentExpression\n *   ElementList, Elision(opt) AssignmentExpression\n *\n * Elision :\n *  ,\n *  Elision ,\n */\nfunction parseArrayLiteralExpression(state: ParserState, access: Access, bindingType: BindingType): ArrayBindingPattern | ArrayLiteral {\n  nextToken(state);\n  const elements = new Array<IsAssign>();\n  while (state.currentToken !== Token.CloseBracket) {\n    if (consumeOpt(state, Token.Comma)) {\n      elements.push($undefined);\n      if (state!.currentToken === Token.CloseBracket) {\n        elements.push($undefined);\n        break;\n      }\n    } else {\n      elements.push(parse(state, access, Precedence.Assign, bindingType & ~BindingType.IsIterator));\n      if (consumeOpt(state, Token.Comma)) {\n        if (state!.currentToken === Token.CloseBracket) {\n          elements.push($undefined);\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  consume(state, Token.CloseBracket);\n  if ((bindingType & BindingType.IsIterator) > 0) {\n    return new ArrayBindingPattern(elements);\n  } else {\n    state.assignable = false;\n    return new ArrayLiteral(elements);\n  }\n}\n\nfunction parseForOfStatement(state: ParserState, result: BindingIdentifier | ArrayBindingPattern | ObjectBindingPattern): ForOfStatement {\n  if ((result.$kind & ExpressionKind.IsForDeclaration) === 0) {\n    throw Reporter.error(SyntaxError.InvalidForDeclaration, { state });\n  }\n  if (state.currentToken !== Token.OfKeyword) {\n    throw Reporter.error(SyntaxError.InvalidForDeclaration, { state });\n  }\n  nextToken(state);\n  const declaration = result;\n  const statement = parse(state, Access.Reset, Precedence.Variadic, BindingType.None);\n  return new ForOfStatement(declaration, statement as IsBindingBehavior);\n}\n\n/**\n * parseObjectLiteralExpression\n * https://tc39.github.io/ecma262/#prod-Literal\n *\n * ObjectLiteral :\n *   { }\n *   { PropertyDefinitionList }\n *\n * PropertyDefinitionList :\n *   PropertyDefinition\n *   PropertyDefinitionList, PropertyDefinition\n *\n * PropertyDefinition :\n *   IdentifierName\n *   PropertyName : AssignmentExpression\n *\n * PropertyName :\n *   IdentifierName\n *   StringLiteral\n *   NumericLiteral\n */\nfunction parseObjectLiteralExpression(state: ParserState, bindingType: BindingType): ObjectBindingPattern | ObjectLiteral {\n  const keys = new Array<string | number>();\n  const values = new Array<IsAssign>();\n  nextToken(state);\n  while (state.currentToken !== Token.CloseBrace) {\n    keys.push(state.tokenValue);\n    // Literal = mandatory colon\n    if ((state.currentToken & Token.StringOrNumericLiteral) > 0) {\n      nextToken(state);\n      consume(state, Token.Colon);\n      values.push(parse(state, Access.Reset, Precedence.Assign, bindingType & ~BindingType.IsIterator));\n    } else if ((state.currentToken & Token.IdentifierName) > 0) {\n      // IdentifierName = optional colon\n      const { currentChar, currentToken, index } = state;\n      nextToken(state);\n      if (consumeOpt(state, Token.Colon)) {\n        values.push(parse(state, Access.Reset, Precedence.Assign, bindingType & ~BindingType.IsIterator));\n      } else {\n        // Shorthand\n        state.currentChar = currentChar;\n        state.currentToken = currentToken;\n        state.index = index;\n        values.push(parse(state, Access.Reset, Precedence.Primary, bindingType & ~BindingType.IsIterator));\n      }\n    } else {\n      throw Reporter.error(SyntaxError.InvalidObjectLiteralPropertyDefinition, { state });\n    }\n    if (state!.currentToken !== Token.CloseBrace) {\n      consume(state, Token.Comma);\n    }\n  }\n  consume(state, Token.CloseBrace);\n  if ((bindingType & BindingType.IsIterator) > 0) {\n    return new ObjectBindingPattern(keys, values);\n  } else {\n    state.assignable = false;\n    return new ObjectLiteral(keys, values);\n  }\n}\n\nfunction parseInterpolation(state: ParserState): Interpolation {\n  const parts = [];\n  const expressions = [];\n  const length = state.length;\n  let result = '';\n  while (state.index < length) {\n    switch (state.currentChar) {\n      case Char.Dollar:\n        if (state.input.charCodeAt(state.index + 1) === Char.OpenBrace) {\n          parts.push(result);\n          result = '';\n\n          state.index += 2;\n          state.currentChar = state.input.charCodeAt(state.index);\n          nextToken(state);\n          const expression = parse(state, Access.Reset, Precedence.Variadic, BindingType.Interpolation);\n          expressions.push(expression);\n          continue;\n        } else {\n          result += '$';\n        }\n        break;\n      case Char.Backslash:\n        result += String.fromCharCode(unescapeCode(nextChar(state)));\n        break;\n      default:\n        result += String.fromCharCode(state.currentChar);\n    }\n    nextChar(state);\n  }\n  if (expressions.length) {\n    parts.push(result);\n    return new Interpolation(parts, expressions);\n  }\n  return null;\n}\n\n/**\n * parseTemplateLiteralExpression\n * https://tc39.github.io/ecma262/#prod-Literal\n *\n * Template :\n *   NoSubstitutionTemplate\n *   TemplateHead\n *\n * NoSubstitutionTemplate :\n *   ` TemplateCharacters(opt) `\n *\n * TemplateHead :\n *   ` TemplateCharacters(opt) ${\n *\n * TemplateSubstitutionTail :\n *   TemplateMiddle\n *   TemplateTail\n *\n * TemplateMiddle :\n *   } TemplateCharacters(opt) ${\n *\n * TemplateTail :\n *   } TemplateCharacters(opt) `\n *\n * TemplateCharacters :\n *   TemplateCharacter TemplateCharacters(opt)\n *\n * TemplateCharacter :\n *   $ [lookahead ≠ {]\n *   \\ EscapeSequence\n *   SourceCharacter (but not one of ` or \\ or $)\n */\nfunction parseTemplate(state: ParserState, access: Access, bindingType: BindingType, result: IsLeftHandSide, tagged: boolean): TaggedTemplate | Template {\n  const cooked = [state.tokenValue as string];\n  //const raw = [state.tokenRaw];\n  consume(state, Token.TemplateContinuation);\n  const expressions = [parse(state, access, Precedence.Assign, bindingType)];\n  while ((state.currentToken = scanTemplateTail(state)) !== Token.TemplateTail) {\n    cooked.push(state.tokenValue as string);\n    // if (tagged) {\n    //   raw.push(state.tokenRaw);\n    // }\n    consume(state, Token.TemplateContinuation);\n    expressions.push(parse(state, access, Precedence.Assign, bindingType));\n  }\n  cooked.push(state.tokenValue as string);\n  state.assignable = false;\n  if (tagged) {\n    //raw.push(state.tokenRaw);\n    nextToken(state);\n    return new TaggedTemplate(cooked, cooked, result, expressions);\n  } else {\n    nextToken(state);\n    return new Template(cooked, expressions);\n  }\n}\n\nfunction nextToken(state: ParserState): void {\n  while (state.index < state.length) {\n    state.startIndex = state.index;\n    if ((state.currentToken = CharScanners[state.currentChar](state)) !== null) { // a null token means the character must be skipped\n      return;\n    }\n  }\n  state.currentToken = Token.EOF;\n}\n\nfunction nextChar(state: ParserState): number {\n  return state.currentChar = state.input.charCodeAt(++state.index);\n}\n\nfunction scanIdentifier(state: ParserState): Token {\n  // run to the next non-idPart\n  while (IdParts[nextChar(state)]);\n\n  return KeywordLookup[state.tokenValue = state.tokenRaw] || Token.Identifier;\n}\n\nfunction scanNumber(state: ParserState, isFloat: boolean): Token {\n  if (isFloat) {\n    state.tokenValue = 0;\n  } else {\n    state.tokenValue = state.currentChar - Char.Zero;\n    while (nextChar(state) <= Char.Nine && state.currentChar >= Char.Zero) {\n      state.tokenValue = state.tokenValue * 10 + state.currentChar  - Char.Zero;\n    }\n  }\n\n  if (isFloat || state.currentChar === Char.Dot) {\n    // isFloat (coming from the period scanner) means the period was already skipped\n    if (!isFloat) {\n      isFloat = true;\n      nextChar(state);\n      if (state.index >= state.length) {\n        // a trailing period is valid javascript, so return here to prevent creating a NaN down below\n        return Token.NumericLiteral;\n      }\n    }\n    // note: this essentially make member expressions on numeric literals valid;\n    // this makes sense to allow since they're always stored in variables, and they can legally be evaluated\n    // this would be consistent with declaring a literal as a normal variable and performing an operation on that\n    const current = state.currentChar;\n    if (current > Char.Nine || current < Char.Zero) {\n      state.currentChar = state.input.charCodeAt(--state.index);\n      return Token.NumericLiteral;\n    }\n    const start = state.index;\n    let value = state.currentChar - Char.Zero;\n    while (nextChar(state) <= Char.Nine && state.currentChar >= Char.Zero) {\n      value = value * 10 + state.currentChar  - Char.Zero;\n    }\n    state.tokenValue = state.tokenValue + value / 10 ** (state.index - start);\n  }\n\n  // in the rare case that we go over this number, re-parse the number with the (slower) native number parsing,\n  // to ensure consistency with the spec\n  if (state.tokenValue > Number.MAX_SAFE_INTEGER) {\n    if (isFloat) {\n      state.tokenValue = parseFloat(state.tokenRaw);\n    } else {\n      state.tokenValue = parseInt(state.tokenRaw, 10);\n    }\n  }\n\n  return Token.NumericLiteral;\n}\n\nfunction scanString(state: ParserState): Token {\n  const quote = state.currentChar;\n  nextChar(state); // Skip initial quote.\n\n  let unescaped = 0;\n  const buffer = new Array<string>();\n  let marker = state.index;\n\n  while (state.currentChar !== quote) {\n    if (state.currentChar === Char.Backslash) {\n      buffer.push(state.input.slice(marker, state.index));\n      nextChar(state);\n      unescaped = unescapeCode(state.currentChar);\n      nextChar(state);\n      buffer.push(String.fromCharCode(unescaped));\n      marker = state.index;\n    } else if (state.index >= state.length) {\n      throw Reporter.error(SyntaxError.UnterminatedQuote, { state });\n    } else {\n      nextChar(state);\n    }\n  }\n\n  const last = state.input.slice(marker, state.index);\n  nextChar(state); // Skip terminating quote.\n\n  // Compute the unescaped string value.\n  buffer.push(last);\n  const unescapedStr = buffer.join('');\n\n  state.tokenValue = unescapedStr;\n  return Token.StringLiteral;\n}\n\nfunction scanTemplate(state: ParserState): Token {\n  let tail = true;\n  let result = '';\n\n  while (nextChar(state) !== Char.Backtick) {\n    if (state.currentChar === Char.Dollar) {\n      if ((state.index + 1) < state.length && state.input.charCodeAt(state.index + 1) === Char.OpenBrace) {\n        state.index++;\n        tail = false;\n        break;\n      } else {\n        result += '$';\n      }\n    } else if (state.currentChar === Char.Backslash) {\n      result += String.fromCharCode(unescapeCode(nextChar(state)));\n    } else {\n      if (state.index >= state.length) {\n        throw Reporter.error(SyntaxError.UnterminatedTemplate, { state });\n      }\n      result += String.fromCharCode(state.currentChar);\n    }\n  }\n\n  nextChar(state);\n  state.tokenValue = result;\n  if (tail) {\n    return Token.TemplateTail;\n  }\n  return Token.TemplateContinuation;\n}\n\nfunction scanTemplateTail(state: ParserState): Token {\n  if (state.index >= state.length) {\n    throw Reporter.error(SyntaxError.UnterminatedTemplate, { state });\n  }\n  state.index--;\n  return scanTemplate(state);\n}\n\nfunction consumeOpt(state: ParserState, token: Token): boolean {\n  // tslint:disable-next-line:possible-timing-attack\n  if (state.currentToken === token) {\n    nextToken(state);\n    return true;\n  }\n\n  return false;\n}\n\nfunction consume(state: ParserState, token: Token): void {\n  // tslint:disable-next-line:possible-timing-attack\n  if (state.currentToken === token) {\n    nextToken(state);\n  } else {\n    throw Reporter.error(SyntaxError.MissingExpectedToken, { state, expected: token });\n  }\n}\n\n/**\n * Array for mapping tokens to token values. The indices of the values\n * correspond to the token bits 0-38.\n * For this to work properly, the values in the array must be kept in\n * the same order as the token bits.\n * Usage: TokenValues[token & Token.Type]\n */\nconst TokenValues = [\n  $false, $true, $null, $undefined, '$this', '$parent',\n\n  '(', '{', '.', '}', ')', ',', '[', ']', ':', '?', '\\'', '\"',\n\n  '&', '|', '||', '&&', '==', '!=', '===', '!==', '<', '>',\n  '<=', '>=', 'in', 'instanceof', '+', '-', 'typeof', 'void', '*', '%', '/', '=', '!',\n  Token.TemplateTail, Token.TemplateContinuation,\n  'of'\n];\n\nconst KeywordLookup: {\n  [key: string]: Token;\n} = Object.create(null);\nKeywordLookup.true = Token.TrueKeyword;\nKeywordLookup.null = Token.NullKeyword;\nKeywordLookup.false = Token.FalseKeyword;\nKeywordLookup.undefined = Token.UndefinedKeyword;\nKeywordLookup.$this = Token.ThisScope;\nKeywordLookup.$parent = Token.ParentScope;\nKeywordLookup.in = Token.InKeyword;\nKeywordLookup.instanceof = Token.InstanceOfKeyword;\nKeywordLookup.typeof = Token.TypeofKeyword;\nKeywordLookup.void = Token.VoidKeyword;\nKeywordLookup.of = Token.OfKeyword;\n\n/**\n * Ranges of code points in pairs of 2 (eg 0x41-0x5B, 0x61-0x7B, ...) where the second value is not inclusive (5-7 means 5 and 6)\n * Single values are denoted by the second value being a 0\n *\n * Copied from output generated with \"node build/generate-unicode.js\"\n *\n * See also: https://en.wikibooks.org/wiki/Unicode/Character_reference/0000-0FFF\n */\nconst codes = {\n  /* [$0-9A-Za_a-z] */\n  AsciiIdPart: [0x24, 0, 0x30, 0x3A, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B],\n  IdStart: /*IdentifierStart*/[0x24, 0, 0x41, 0x5B, 0x5F, 0, 0x61, 0x7B, 0xAA, 0, 0xBA, 0, 0xC0, 0xD7, 0xD8, 0xF7, 0xF8, 0x2B9, 0x2E0, 0x2E5, 0x1D00, 0x1D26, 0x1D2C, 0x1D5D, 0x1D62, 0x1D66, 0x1D6B, 0x1D78, 0x1D79, 0x1DBF, 0x1E00, 0x1F00, 0x2071, 0, 0x207F, 0, 0x2090, 0x209D, 0x212A, 0x212C, 0x2132, 0, 0x214E, 0, 0x2160, 0x2189, 0x2C60, 0x2C80, 0xA722, 0xA788, 0xA78B, 0xA7AF, 0xA7B0, 0xA7B8, 0xA7F7, 0xA800, 0xAB30, 0xAB5B, 0xAB5C, 0xAB65, 0xFB00, 0xFB07, 0xFF21, 0xFF3B, 0xFF41, 0xFF5B],\n  Digit: /*DecimalNumber*/[0x30, 0x3A],\n  Skip: /*Skippable*/[0, 0x21, 0x7F, 0xA1]\n};\n\n/**\n * Decompress the ranges into an array of numbers so that the char code\n * can be used as an index to the lookup\n */\nfunction decompress(lookup: (CharScanner | number)[] | null, $set: Set<number> | null, compressed: number[], value: CharScanner | number | boolean): void {\n  const rangeCount = compressed.length;\n  for (let i = 0; i < rangeCount; i += 2) {\n    const start = compressed[i];\n    let end = compressed[i + 1];\n    end = end > 0 ? end : start + 1;\n    if (lookup) {\n      lookup.fill(<CharScanner | number>value, start, end);\n    }\n    if ($set) {\n      for (let ch = start; ch < end; ch++) {\n        $set.add(ch);\n      }\n    }\n  }\n}\n\n// CharFuncLookup functions\nfunction returnToken(token: Token): (s: ParserState) => Token {\n  return s => {\n    nextChar(s);\n    return token;\n  };\n}\nconst unexpectedCharacter: CharScanner = s => {\n  throw Reporter.error(SyntaxError.UnexpectedCharacter, { state: s });\n};\nunexpectedCharacter.notMapped = true;\n\n// ASCII IdentifierPart lookup\nconst AsciiIdParts = new Set();\ndecompress(null, AsciiIdParts, codes.AsciiIdPart, true);\n\n// IdentifierPart lookup\nconst IdParts = new Uint8Array(0xFFFF);\n// tslint:disable-next-line:no-any\ndecompress(<any>IdParts, null, codes.IdStart, 1);\n// tslint:disable-next-line:no-any\ndecompress(<any>IdParts, null, codes.Digit, 1);\n\ntype CharScanner = ((p: ParserState) => Token | null) & { notMapped?: boolean };\n\n// Character scanning function lookup\nconst CharScanners = new Array<CharScanner>(0xFFFF);\nCharScanners.fill(unexpectedCharacter, 0, 0xFFFF);\n\ndecompress(CharScanners, null, codes.Skip, s => {\n  nextChar(s);\n  return null;\n});\ndecompress(CharScanners, null, codes.IdStart, scanIdentifier);\ndecompress(CharScanners, null, codes.Digit, s => scanNumber(s, false));\n\nCharScanners[Char.DoubleQuote] =\nCharScanners[Char.SingleQuote] = s => {\n  return scanString(s);\n};\nCharScanners[Char.Backtick] = s => {\n  return scanTemplate(s);\n};\n\n// !, !=, !==\nCharScanners[Char.Exclamation] = s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.Exclamation;\n  }\n  if (nextChar(s) !== Char.Equals) {\n    return Token.ExclamationEquals;\n  }\n  nextChar(s);\n  return Token.ExclamationEqualsEquals;\n};\n\n// =, ==, ===\nCharScanners[Char.Equals] =  s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.Equals;\n  }\n  if (nextChar(s) !== Char.Equals) {\n    return Token.EqualsEquals;\n  }\n  nextChar(s);\n  return Token.EqualsEqualsEquals;\n};\n\n// &, &&\nCharScanners[Char.Ampersand] = s => {\n  if (nextChar(s) !== Char.Ampersand) {\n    return Token.Ampersand;\n  }\n  nextChar(s);\n  return Token.AmpersandAmpersand;\n};\n\n// |, ||\nCharScanners[Char.Bar] = s => {\n  if (nextChar(s) !== Char.Bar) {\n    return Token.Bar;\n  }\n  nextChar(s);\n  return Token.BarBar;\n};\n\n// .\nCharScanners[Char.Dot] = s => {\n  if (nextChar(s) <= Char.Nine && s.currentChar >= Char.Zero) {\n    return scanNumber(s, true);\n  }\n  return Token.Dot;\n};\n\n// <, <=\nCharScanners[Char.LessThan] =  s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.LessThan;\n  }\n  nextChar(s);\n  return Token.LessThanEquals;\n};\n\n// >, >=\nCharScanners[Char.GreaterThan] =  s => {\n  if (nextChar(s) !== Char.Equals) {\n    return Token.GreaterThan;\n  }\n  nextChar(s);\n  return Token.GreaterThanEquals;\n};\n\nCharScanners[Char.Percent]      = returnToken(Token.Percent);\nCharScanners[Char.OpenParen]    = returnToken(Token.OpenParen);\nCharScanners[Char.CloseParen]   = returnToken(Token.CloseParen);\nCharScanners[Char.Asterisk]     = returnToken(Token.Asterisk);\nCharScanners[Char.Plus]         = returnToken(Token.Plus);\nCharScanners[Char.Comma]        = returnToken(Token.Comma);\nCharScanners[Char.Minus]        = returnToken(Token.Minus);\nCharScanners[Char.Slash]        = returnToken(Token.Slash);\nCharScanners[Char.Colon]        = returnToken(Token.Colon);\nCharScanners[Char.Question]     = returnToken(Token.Question);\nCharScanners[Char.OpenBracket]  = returnToken(Token.OpenBracket);\nCharScanners[Char.CloseBracket] = returnToken(Token.CloseBracket);\nCharScanners[Char.OpenBrace]    = returnToken(Token.OpenBrace);\nCharScanners[Char.CloseBrace]   = returnToken(Token.CloseBrace);\n","import { DI, inject, PLATFORM } from '@au-test/kernel';\nimport { DOM, INode } from '@au-test/runtime';\nimport { AttrSyntax, IAttributeParser } from './attribute-parser';\n\nconst domParser = <HTMLDivElement>DOM.createElement('div');\n\nexport const enum NodeType {\n  Element = 1,\n  Attr = 2,\n  Text = 3,\n  CDATASection = 4,\n  EntityReference = 5,\n  Entity = 6,\n  ProcessingInstruction = 7,\n  Comment = 8,\n  Document = 9,\n  DocumentType = 10,\n  DocumentFragment = 11,\n  Notation = 12\n}\n\nconst marker = DOM.createElement('au-marker') as Element;\nmarker.classList.add('au');\nconst createMarker: () => HTMLElement = marker.cloneNode.bind(marker, false);\n\nexport class ElementSyntax {\n  constructor(\n    public readonly node: Node,\n    public readonly name: string,\n    public readonly $content: ElementSyntax | null,\n    public readonly $children: ReadonlyArray<ElementSyntax>,\n    public readonly $attributes: ReadonlyArray<AttrSyntax>) {\n    }\n\n  public static createMarker(): ElementSyntax {\n    return new ElementSyntax(createMarker(), 'au-marker', null, PLATFORM.emptyArray, PLATFORM.emptyArray);\n  }\n}\n\nexport interface IElementParser {\n  parse(markupOrNode: string | INode): ElementSyntax;\n}\n\nexport const IElementParser = DI.createInterface<IElementParser>()\n  .withDefault(x => x.singleton(ElementParser));\n\n/*@internal*/\n@inject(IAttributeParser)\nexport class ElementParser implements IElementParser {\n  constructor(public attrParser: IAttributeParser) {}\n\n  public parse(markupOrNode: string | INode): ElementSyntax {\n    let node: Element;\n    if (typeof markupOrNode === 'string') {\n      domParser.innerHTML = markupOrNode;\n      node = domParser.firstElementChild;\n      domParser.removeChild(node);\n    } else {\n      node = markupOrNode as Element;\n    }\n\n    let children: ElementSyntax[];\n    let content: ElementSyntax;\n    if (node.nodeName === 'TEMPLATE') {\n      content = this.parse((<HTMLTemplateElement>node).content);\n      children = PLATFORM.emptyArray as ElementSyntax[];\n    } else {\n      content = null;\n      const nodeChildNodes = node.childNodes;\n      const nodeLen = nodeChildNodes.length;\n      if (nodeLen > 0) {\n        children = Array(nodeLen);\n        for (let i = 0, ii = nodeLen; i < ii; ++i) {\n          children[i] = this.parse(nodeChildNodes[i]);\n        }\n      } else {\n        children = PLATFORM.emptyArray as ElementSyntax[];\n      }\n    }\n\n    let attributes: AttrSyntax[];\n    const nodeAttributes = node.attributes;\n    const attrLen = nodeAttributes && nodeAttributes.length || 0;\n    if (attrLen > 0) {\n      attributes = Array(attrLen);\n      for (let i = 0, ii = attrLen; i < ii; ++i) {\n        const attr = nodeAttributes[i];\n        attributes[i] = this.attrParser.parse(attr.name, attr.value);\n      }\n    } else {\n      attributes = PLATFORM.emptyArray as AttrSyntax[];\n    }\n\n    return new ElementSyntax(node, node.nodeName, content, children, attributes);\n  }\n}\n","import { Immutable, IServiceLocator, PLATFORM } from '@au-test/kernel';\nimport { BindingMode, CustomAttributeResource, CustomElementResource, DOM, IBindableDescription, ICustomAttributeSource, IExpressionParser, IResourceDescriptions, ITemplateSource, TargetedInstruction } from '@au-test/runtime';\nimport { AttrSyntax, IAttributeParser } from './attribute-parser';\nimport { BindingCommandResource,  IBindingCommand } from './binding-command';\nimport { Char } from './common';\nimport { ElementSyntax, IElementParser, NodeType } from './element-parser';\nimport { HydrateTemplateController } from './instructions';\n\nexport class SemanticModel {\n  public readonly isSemanticModel: true = true;\n  public readonly root: ElementSymbol;\n\n  private readonly attrDefCache: Record<string, ICustomAttributeSource>;\n  private readonly elDefCache: Record<string, ITemplateSource>;\n  private readonly commandCache: Record<string, IBindingCommand>;\n\n  private constructor(\n    definition: ITemplateSource,\n    public resources: IResourceDescriptions,\n    public attrParser: IAttributeParser,\n    public elParser: IElementParser,\n    public exprParser: IExpressionParser\n  ) {\n    this.attrDefCache = {};\n    this.elDefCache = {};\n    this.commandCache = {};\n    const syntax = this.elParser.parse(definition.templateOrNode);\n    definition.templateOrNode = syntax.node;\n    this.root = new ElementSymbol(\n      /*   semanticModel*/this,\n      /*isDefinitionRoot*/true,\n      /* $definitionRoot*/null,\n      /*         $parent*/null,\n      /*          syntax*/syntax,\n      /*      definition*/definition\n    );\n  }\n\n  public static create(\n    definition: ITemplateSource,\n    resources: IResourceDescriptions,\n    attrParser: IAttributeParser,\n    elParser: IElementParser,\n    exprParser: IExpressionParser): SemanticModel;\n  public static create(\n    definition: ITemplateSource,\n    resources: IResourceDescriptions,\n    locator: IServiceLocator): SemanticModel;\n  public static create(\n    definition: ITemplateSource,\n    resources: IResourceDescriptions,\n    attrParser: IServiceLocator | IAttributeParser,\n    elParser?: IElementParser,\n    exprParser?: IExpressionParser): SemanticModel {\n\n    if ('get' in attrParser) {\n      const locator = attrParser as IServiceLocator;\n      attrParser = locator.get<IAttributeParser>(IAttributeParser);\n      elParser = locator.get<IElementParser>(IElementParser);\n      exprParser = locator.get<IExpressionParser>(IExpressionParser);\n    }\n\n    return new SemanticModel(definition, resources, attrParser, elParser, exprParser);\n  }\n\n  public getAttributeDefinition(name: string): ICustomAttributeSource {\n    const existing = this.attrDefCache[name];\n    if (existing !== undefined) {\n      return existing;\n    }\n    const definition = <ICustomAttributeSource>this.resources.find(CustomAttributeResource, name) || null;\n    return this.attrDefCache[name] = definition;\n  }\n\n  public getElementDefinition(name: string): ITemplateSource {\n    const existing = this.elDefCache[name];\n    if (existing !== undefined) {\n      return existing;\n    }\n    const definition = <ITemplateSource>this.resources.find(CustomElementResource, name) || null;\n    return this.elDefCache[name] = definition;\n  }\n\n  public getBindingCommand(name: string): IBindingCommand {\n    const existing = this.commandCache[name];\n    if (existing !== undefined) {\n      return existing;\n    }\n    const instance = this.resources.create(BindingCommandResource, name) || null;\n    return this.commandCache[name] = instance;\n  }\n\n  public getAttributeSymbol(syntax: AttrSyntax, element: ElementSymbol): AttributeSymbol {\n    const definition = this.getAttributeDefinition(PLATFORM.camelCase(syntax.target));\n    const command = this.getBindingCommand(syntax.command);\n    return new AttributeSymbol(this, element, syntax, definition, command);\n  }\n\n  public getMultiAttrBindingSymbol(syntax: AttrSyntax, parent: AttributeSymbol): MultiAttributeBindingSymbol {\n    const command = this.getBindingCommand(syntax.command);\n    return new MultiAttributeBindingSymbol(this, parent, syntax, command);\n  }\n\n  public getElementSymbol(syntax: ElementSyntax, parent: ElementSymbol): ElementSymbol {\n    const node = syntax.node as Element;\n    let definition: ITemplateSource;\n    if (node.nodeType === NodeType.Element) {\n      const resourceKey = (node.getAttribute('as-element') || node.nodeName).toLowerCase();\n      definition = this.getElementDefinition(resourceKey);\n    }\n\n    return new ElementSymbol(\n      /*   semanticModel*/this,\n      /*isDefinitionRoot*/false,\n      /* $definitionRoot*/parent.$root,\n      /*         $parent*/parent,\n      /*          syntax*/syntax,\n      /*      definition*/definition\n    );\n  }\n\n  public getTemplateElementSymbol(syntax: ElementSyntax, parent: ElementSymbol, definition: ITemplateSource, definitionRoot: ElementSymbol): ElementSymbol {\n    return new ElementSymbol(\n      /*   semanticModel*/this,\n      /*isDefinitionRoot*/true,\n      /* $definitionRoot*/definitionRoot,\n      /*         $parent*/parent,\n      /*          syntax*/syntax,\n      /*      definition*/definition\n    );\n  }\n}\n\nexport interface IAttributeSymbol {\n  readonly isMultiAttrBinding: boolean;\n  readonly target: string;\n  readonly res: string | null;\n  readonly rawName: string;\n  readonly rawValue: string;\n  readonly rawCommand: string;\n  readonly syntax: AttrSyntax;\n  readonly command: IBindingCommand | null;\n  readonly dest: string;\n  readonly mode: BindingMode;\n  readonly bindable: IBindableDescription;\n  readonly hasBindingCommand: boolean;\n  readonly isHandledByBindingCommand: boolean;\n  readonly isTemplateController: boolean;\n  readonly isCustomAttribute: boolean;\n  readonly isAttributeBindable: boolean;\n  readonly isDefaultAttributeBindable: boolean;\n  readonly onCustomElement: boolean;\n  readonly isElementBindable: boolean;\n  readonly $element: ElementSymbol;\n}\n\nexport class MultiAttributeBindingSymbol implements IAttributeSymbol {\n  public readonly isMultiAttrBinding: boolean = true;\n  public readonly target: string;\n  public readonly res: string = null;\n  public readonly rawName: string;\n  public readonly rawValue: string;\n  public readonly rawCommand: string | null;\n  public readonly dest: string;\n  public readonly mode: BindingMode;\n  public readonly bindable: Immutable<Required<IBindableDescription>> | null = null;\n  public readonly hasBindingCommand: boolean;\n  public readonly isHandledByBindingCommand: boolean;\n  public readonly isTemplateController: boolean = false;\n  public readonly isCustomAttribute: boolean = true;\n  public readonly isAttributeBindable: boolean = false;\n  public readonly isDefaultAttributeBindable: boolean = false;\n  public readonly onCustomElement: boolean = false;\n  public readonly isElementBindable: boolean = false;\n  public readonly $element: ElementSymbol = null;\n\n  constructor(\n    public readonly semanticModel: SemanticModel,\n    public readonly $parent: AttributeSymbol,\n    public readonly syntax: AttrSyntax,\n    public readonly command: IBindingCommand | null\n  ) {\n    this.target = syntax.target;\n    this.rawName = syntax.rawName;\n    this.rawValue = syntax.rawValue;\n    this.rawCommand = syntax.command;\n    this.hasBindingCommand = !!command;\n    this.isHandledByBindingCommand = this.hasBindingCommand && command.handles(this);\n    const bindables = $parent.definition.bindables;\n    for (const prop in bindables) {\n      const b = bindables[prop];\n      if (b.property === syntax.target) {\n        this.dest = b.property;\n        this.mode =  (b.mode && b.mode !== BindingMode.default) ? b.mode : BindingMode.toView;\n        this.bindable = b as Immutable<Required<IBindableDescription>>;\n        this.isAttributeBindable = true;\n        break;\n      }\n    }\n    if (!this.isAttributeBindable) {\n      this.dest = syntax.target;\n      this.mode = $parent.definition.defaultBindingMode || BindingMode.toView;\n    }\n  }\n}\n\nexport class AttributeSymbol implements IAttributeSymbol {\n  public readonly isMultiAttrBinding: boolean = false;\n  public readonly $multiAttrBindings: ReadonlyArray<MultiAttributeBindingSymbol>;\n  public readonly target: string;\n  public readonly res: string | null = null;\n  public readonly rawName: string;\n  public readonly rawValue: string;\n  public readonly rawCommand: string | null;\n  public readonly dest: string;\n  public readonly mode: BindingMode;\n  public readonly bindable: Immutable<Required<IBindableDescription>> | null = null;\n  public readonly isAttributeBindable: boolean = false;\n  public readonly isDefaultAttributeBindable: boolean = false;\n  public readonly isCustomAttribute: boolean;\n  public readonly isElementBindable: boolean = false;\n  public readonly onCustomElement: boolean;\n  public readonly isBindable: boolean = false;\n  public readonly isTemplateController: boolean = false;\n  public readonly hasBindingCommand: boolean;\n  public readonly isHandledByBindingCommand: boolean;\n  private _isProcessed: boolean;\n  public get isProcessed(): boolean {\n    return this._isProcessed;\n  }\n\n  constructor(\n    public readonly semanticModel: SemanticModel,\n    public readonly $element: ElementSymbol,\n    public readonly syntax: AttrSyntax,\n    public readonly definition: ICustomAttributeSource | null,\n    public readonly command: IBindingCommand | null\n  ) {\n    this.target = syntax.target;\n    this.rawName = syntax.rawName;\n    this.rawValue = syntax.rawValue;\n    this.rawCommand = syntax.command;\n    this.isCustomAttribute = !!definition;\n    this.hasBindingCommand = !!command;\n    this.isHandledByBindingCommand = this.hasBindingCommand && command.handles(this);\n    this.onCustomElement = $element.isCustomElement;\n    this._isProcessed = this.rawName === 'as-element'; // as-element is processed by the semantic model and shouldn't be processed by the template compiler\n    if (this.isCustomAttribute) {\n      this.isTemplateController = !!definition.isTemplateController;\n      this.res = definition.name;\n      const value = syntax.rawValue;\n      let lastIndex = 0;\n      let multiAttrBindings: MultiAttributeBindingSymbol[];\n      for (let i = 0, ii = value.length; i < ii; ++i) {\n        if (value.charCodeAt(i) === Char.Semicolon) {\n          if (!this.isMultiAttrBinding) {\n            multiAttrBindings = [];\n            this.isMultiAttrBinding = true;\n          }\n          const innerAttr = value.slice(lastIndex, i).trim();\n          lastIndex = i + 1;\n          if (innerAttr.length === 0) {\n            continue;\n          }\n          for (let j = 0, jj = innerAttr.length; j < jj; ++j) {\n            if (innerAttr.charCodeAt(j) === Char.Colon) {\n              const innerAttrName = innerAttr.slice(0, j).trim();\n              const innerAttrValue = innerAttr.slice(j + 1).trim();\n              const innerAttrSyntax = this.semanticModel.attrParser.parse(innerAttrName, innerAttrValue);\n              multiAttrBindings.push(this.semanticModel.getMultiAttrBindingSymbol(innerAttrSyntax, this));\n            }\n          }\n        }\n      }\n      this.$multiAttrBindings = this.isMultiAttrBinding ? multiAttrBindings : PLATFORM.emptyArray;\n      const bindables = definition.bindables;\n      if (!this.isMultiAttrBinding) {\n        for (const prop in bindables) {\n          const b = bindables[prop];\n          this.dest = b.property;\n          this.mode =  (b.mode && b.mode !== BindingMode.default) ? b.mode : (definition.defaultBindingMode || BindingMode.toView);\n          this.bindable = b as Immutable<Required<IBindableDescription>>;\n          this.isBindable = this.isAttributeBindable = true;\n          break;\n        }\n        if (!this.isAttributeBindable) {\n          this.dest = 'value';\n          this.mode = definition.defaultBindingMode || BindingMode.toView;\n          this.isBindable = this.isAttributeBindable = this.isDefaultAttributeBindable = true;\n        }\n      }\n    } else if ($element.isCustomElement) {\n      const bindables = $element.definition.bindables;\n      for (const prop in bindables) {\n        const b = bindables[prop];\n        if (b.attribute === syntax.target) {\n          this.dest = b.property;\n          this.mode = (b.mode && b.mode !== BindingMode.default) ? b.mode : BindingMode.toView;\n          this.bindable = b as Immutable<Required<IBindableDescription>>;\n          this.isBindable = this.isElementBindable = true;\n          break;\n        }\n      }\n      if (!this.isElementBindable) {\n        this.dest = syntax.target;\n        this.mode = BindingMode.toView;\n      }\n    } else {\n      this.dest = syntax.target;\n      this.mode = BindingMode.toView;\n    }\n  }\n\n  public markAsProcessed(): void {\n    this._isProcessed = true;\n    if (this.isTemplateController) {\n      (<Element>this.$element.node).removeAttribute(this.rawName);\n    }\n  }\n}\n\nexport class ElementSymbol {\n  public readonly $attributes: ReadonlyArray<AttributeSymbol>;\n  public readonly $children: ReadonlyArray<ElementSymbol>;\n  public readonly $liftedChildren: ReadonlyArray<ElementSymbol>;\n  public get $content(): ElementSymbol {\n    return this._$content;\n  }\n  public get isMarker(): boolean {\n    return this._isMarker;\n  }\n  public get isTemplate(): boolean {\n    return this._isTemplate;\n  }\n  public get isSlot(): boolean {\n    return this._isSlot;\n  }\n  public get isLet(): boolean {\n    return this._isLet;\n  }\n  public get node(): Node {\n    return this._node;\n  }\n  public get syntax(): ElementSyntax {\n    return this._syntax;\n  }\n  public get name(): string {\n    return this._name;\n  }\n  public get isCustomElement(): boolean {\n    return this._isCustomElement;\n  }\n  public get nextSibling(): ElementSymbol {\n    if (!this.$parent) {\n      return null;\n    }\n    const siblings = this.$parent.$children;\n    for (let i = 0, ii = siblings.length; i < ii; ++i) {\n      if (siblings[i] === this) {\n        return siblings[i + 1] || null;\n      }\n    }\n    return null;\n  }\n  public get firstChild(): ElementSymbol {\n    return this.$children[0] || null;\n  }\n  public get componentRoot(): ElementSymbol {\n    return this.semanticModel.root;\n  }\n  public get isLifted(): boolean {\n    return this._isLifted;\n  }\n  private _$content: ElementSymbol = null;\n  private _isMarker: boolean = false;\n  private _isTemplate: boolean = false;\n  private _isSlot: boolean = false;\n  private _isLet: boolean = false;\n  private _node: Node;\n  private _syntax: ElementSyntax;\n  private _name: string;\n  private _isCustomElement: boolean;\n  private _isLifted: boolean = false;\n\n  constructor(\n    public readonly semanticModel: SemanticModel,\n    public readonly isRoot: boolean,\n    public readonly $root: ElementSymbol,\n    public readonly $parent: ElementSymbol,\n    syntax: ElementSyntax,\n    public readonly definition: ITemplateSource | null\n  ) {\n    this.$root = isRoot ? this : $root;\n    this._node = syntax.node;\n    this._syntax = syntax;\n    this._name = this.node.nodeName;\n    switch (this.name) {\n      case 'TEMPLATE':\n        this._isTemplate = true;\n        this._$content = this.semanticModel.getElementSymbol(syntax.$content, this);\n        break;\n      case 'SLOT':\n        this._isSlot = true;\n        break;\n      case 'LET':\n        this._isLet = true;\n    }\n    this._isCustomElement = !isRoot && !!definition;\n\n    const attributes = syntax.$attributes;\n    const attrLen = attributes.length;\n    if (attrLen > 0) {\n      const attrSymbols = Array<AttributeSymbol>(attrLen);\n      for (let i = 0, ii = attrLen; i < ii; ++i) {\n        attrSymbols[i] = this.semanticModel.getAttributeSymbol(attributes[i], this);\n      }\n      this.$attributes = attrSymbols;\n    } else {\n      this.$attributes = PLATFORM.emptyArray as AttributeSymbol[];\n    }\n\n    const children = syntax.$children;\n    const childLen = children.length;\n    if (childLen > 0) {\n      const childSymbols = Array<ElementSymbol>(childLen);\n      for (let i = 0, ii = childLen; i < ii; ++i) {\n        childSymbols[i] = this.semanticModel.getElementSymbol(children[i], this);\n      }\n      this.$children = childSymbols;\n    } else {\n      this.$children = PLATFORM.emptyArray as ElementSymbol[];\n    }\n  }\n\n  public makeTarget(): void {\n    (<Element>this.node).classList.add('au');\n  }\n\n  public replaceTextNodeWithMarker(): void {\n    const marker = ElementSyntax.createMarker();\n    const node = this.node;\n    node.parentNode.insertBefore(marker.node, node);\n    node.textContent = ' ';\n    while (node.nextSibling && node.nextSibling.nodeType === NodeType.Text) {\n      node.parentNode.removeChild(node.nextSibling);\n    }\n    this.setToMarker(marker);\n  }\n\n  public replaceNodeWithMarker(): void {\n    const marker = ElementSyntax.createMarker();\n    const node = this.node;\n    if (node.parentNode) {\n      node.parentNode.replaceChild(marker.node, node);\n    } else if (this.isTemplate) {\n      (<HTMLTemplateElement>node).content.appendChild(marker.node);\n    }\n    this.setToMarker(marker);\n  }\n\n  public lift(instruction: HydrateTemplateController): ElementSymbol {\n    const template = instruction.src.templateOrNode = DOM.createTemplate() as HTMLTemplateElement;\n    const node = this.node as HTMLTemplateElement;\n    if (this.isTemplate) {\n      // copy remaining attributes over to the newly created template\n      const attributes = node.attributes;\n      while (attributes.length) {\n        const attr = attributes[0];\n        template.setAttribute(attr.name, attr.value);\n        node.removeAttribute(attr.name);\n      }\n      template.content.appendChild(node.content);\n      this.replaceNodeWithMarker();\n    } else {\n      this.replaceNodeWithMarker();\n      template.content.appendChild(node);\n    }\n    this.addInstructions([instruction]);\n    this._isLifted = true;\n    return this.semanticModel.getTemplateElementSymbol(\n      this.semanticModel.elParser.parse(template), this, instruction.src, null\n    );\n  }\n\n  public addInstructions(instructions: TargetedInstruction[]): void {\n    this.$root.definition.instructions.push(instructions);\n  }\n\n  private setToMarker(marker: ElementSyntax): void {\n    this._$content = null;\n    this._isCustomElement = this._isLet = this._isSlot = this._isTemplate = false;\n    this._isMarker = true;\n    this._name = 'AU-MARKER';\n    this._node = marker.node;\n    this._syntax = marker;\n  }\n}\n","import { inject, PLATFORM } from '@au-test/kernel';\nimport {\n  BindingMode,\n  BindingType,\n  IExpressionParser,\n  ILetBindingInstruction,\n  IResourceDescriptions,\n  ITemplateCompiler,\n  ITemplateSource,\n  TargetedInstruction,\n  TargetedInstructionType,\n  TemplateDefinition,\n  ViewCompileFlags\n} from '@au-test/runtime';\nimport { IAttributeParser } from './attribute-parser';\nimport {  IElementParser, NodeType } from './element-parser';\nimport {\n  FromViewBindingInstruction,\n  HydrateAttributeInstruction,\n  HydrateElementInstruction,\n  HydrateTemplateController,\n  InterpolationInstruction,\n  LetBindingInstruction,\n  LetElementInstruction,\n  OneTimeBindingInstruction,\n  RefBindingInstruction,\n  SetAttributeInstruction,\n  SetPropertyInstruction,\n  TextBindingInstruction,\n  ToViewBindingInstruction,\n  TwoWayBindingInstruction\n} from './instructions';\nimport { AttributeSymbol, ElementSymbol, IAttributeSymbol, SemanticModel } from './semantic-model';\n\n@inject(IExpressionParser, IElementParser, IAttributeParser)\nexport class TemplateCompiler implements ITemplateCompiler {\n  public get name(): string {\n    return 'default';\n  }\n\n  constructor(public exprParser: IExpressionParser, public elParser: IElementParser, public attrParser: IAttributeParser) { }\n\n  public compile(definition: ITemplateSource, resources: IResourceDescriptions, flags?: ViewCompileFlags): TemplateDefinition {\n    const model = SemanticModel.create(definition, resources, this.attrParser, this.elParser, this.exprParser);\n    const root = model.root;\n    let $el = root.isTemplate ? root.$content : root;\n    while ($el = this.compileNode($el));\n\n    // the flag should be passed correctly from rendering engine\n    if (root.isTemplate && (flags & ViewCompileFlags.surrogate)) {\n      this.compileSurrogate(root);\n    }\n\n    return <TemplateDefinition>definition;\n  }\n\n  private compileNode($el: ElementSymbol): ElementSymbol {\n    const node = $el.node;\n    const nextSibling = $el.nextSibling;\n    switch (node.nodeType) {\n      case NodeType.Element:\n        if ($el.isSlot) {\n          $el.$root.definition.hasSlots = true;\n        } else if ($el.isLet) {\n          this.compileLetElement($el);\n        } else if ($el.isCustomElement) {\n          this.compileCustomElement($el);\n        } else {\n          this.compileElementNode($el);\n        }\n        if (!$el.isLifted) {\n          let $child = $el.firstChild || $el.$content;\n          while ($child) {\n            $child = this.compileNode($child);\n          }\n        }\n        return nextSibling;\n      case NodeType.Text:\n        const expression = this.exprParser.parse((<Text>$el.node).wholeText, BindingType.Interpolation);\n        if (expression === null) {\n          while (($el = $el.nextSibling) && $el.node.nodeType === NodeType.Text);\n          return $el;\n        }\n        $el.replaceTextNodeWithMarker();\n        $el.addInstructions([new TextBindingInstruction(expression)]);\n        return nextSibling;\n      case NodeType.Comment:\n        return nextSibling;\n      case NodeType.Document:\n        return $el.firstChild;\n      case NodeType.DocumentType:\n        return nextSibling;\n      case NodeType.DocumentFragment:\n        return $el.firstChild;\n    }\n  }\n\n  private compileSurrogate($el: ElementSymbol): void {\n    const attributes = $el.$attributes;\n    for (let i = 0, ii = attributes.length; i < ii; ++i) {\n      const $attr = attributes[i];\n      if ($attr.isTemplateController) {\n        throw new Error('Cannot have template controller on surrogate element.');\n      }\n      const instruction = this.compileAttribute($attr);\n      if (instruction !== null) {\n        $el.definition.surrogates.push(instruction);\n      } else {\n        let attrInst: TargetedInstruction;\n        // Doesn't make sense for these properties as they need to be unique\n        const name = $attr.target;\n        if (name !== 'id' && name !== 'part' && name !== 'replace-part') {\n          switch (name) {\n            // TODO: handle simple surrogate style attribute\n            case 'style':\n              attrInst = new SetAttributeInstruction($attr.rawValue, name);\n              break;\n            default:\n              attrInst = new SetAttributeInstruction($attr.rawValue, name);\n          }\n          $el.definition.surrogates.push(attrInst);\n        } else {\n          throw new Error(`Invalid surrogate attribute: ${name}`);\n        }\n      }\n    }\n  }\n\n  private compileElementNode($el: ElementSymbol): void {\n    if ($el.$attributes.length === 0) {\n      return;\n    }\n    const attributes = $el.$attributes;\n    const attributeInstructions: TargetedInstruction[] = [];\n    for (let i = 0, ii = attributes.length; i < ii; ++i) {\n      const $attr = attributes[i];\n      if ($attr.isProcessed) continue;\n      $attr.markAsProcessed();\n      if ($attr.isTemplateController) {\n        let instruction = this.compileAttribute($attr);\n        // compileAttribute will return a HydrateTemplateController if there is a binding command registered that produces one (in our case only \"for\")\n        if (instruction.type !== TargetedInstructionType.hydrateTemplateController) {\n          const name = $attr.res;\n          instruction = new HydrateTemplateController({ name, instructions: [] }, name, [instruction], name === 'else');\n        }\n        // all attribute instructions preceding the template controller become children of the hydrate instruction\n        instruction.instructions.push(...attributeInstructions);\n        this.compileNode($el.lift(instruction));\n        return;\n      } else if ($attr.isCustomAttribute) {\n        attributeInstructions.push(this.compileCustomAttribute($attr));\n      } else {\n        const instruction = this.compileAttribute($attr);\n        if (instruction !== null) {\n          attributeInstructions.push(instruction);\n        }\n      }\n    }\n    if (attributeInstructions.length) {\n      $el.addInstructions(attributeInstructions);\n      $el.makeTarget();\n    }\n  }\n\n  private compileCustomElement($el: ElementSymbol): void {\n    if ($el.$attributes.length === 0) {\n      $el.addInstructions([new HydrateElementInstruction($el.definition.name, <any>PLATFORM.emptyArray)]);\n      $el.makeTarget();\n      return;\n    }\n    const attributeInstructions: TargetedInstruction[] = [];\n    // if there is a custom element, then only the attributes that map to bindables become children of the hydrate instruction,\n    // otherwise they become sibling instructions; if there is no custom element, then sibling instructions are never appended to\n    const siblingInstructions: TargetedInstruction[] = [];\n    const attributes = $el.$attributes;\n    for (let i = 0, ii = attributes.length; i < ii; ++i) {\n      const $attr = attributes[i];\n      if ($attr.isProcessed) continue;\n      $attr.markAsProcessed();\n      if ($attr.isTemplateController) {\n        let instruction = this.compileAttribute($attr);\n        // compileAttribute will return a HydrateTemplateController if there is a binding command registered that produces one (in our case only \"for\")\n        if (instruction.type !== TargetedInstructionType.hydrateTemplateController) {\n          const name = $attr.res;\n          instruction = new HydrateTemplateController({ name, instructions: [] }, name, [instruction], name === 'else');\n        }\n        // all attribute instructions preceding the template controller become children of the hydrate instruction\n        instruction.instructions.push(...attributeInstructions);\n        this.compileNode($el.lift(instruction));\n        return;\n      } else if ($attr.isCustomAttribute) {\n        if ($attr.isAttributeBindable) {\n          siblingInstructions.push(this.compileCustomAttribute($attr));\n        } else {\n          attributeInstructions.push(this.compileCustomAttribute($attr));\n        }\n      } else {\n        const instruction = this.compileAttribute($attr);\n        if (instruction !== null) {\n          if (!$attr.isElementBindable) {\n            siblingInstructions.push(instruction);\n          } else {\n            attributeInstructions.push(instruction);\n          }\n        }\n      }\n    }\n    $el.addInstructions([new HydrateElementInstruction($el.definition.name, attributeInstructions), ...siblingInstructions]);\n    $el.makeTarget();\n  }\n\n  private compileCustomAttribute($attr: AttributeSymbol): HydrateAttributeInstruction {\n    const childInstructions = [];\n    if ($attr.isMultiAttrBinding) {\n      const mBindings = $attr.$multiAttrBindings;\n      for (let j = 0, jj = mBindings.length; j < jj; ++j) {\n        childInstructions.push(this.compileAttribute(mBindings[j]));\n      }\n    } else {\n      childInstructions.push(this.compileAttribute($attr));\n    }\n    return new HydrateAttributeInstruction($attr.res, childInstructions);\n  }\n\n  private compileLetElement($el: ElementSymbol): void {\n    const letInstructions: ILetBindingInstruction[] = [];\n    const attributes = $el.$attributes;\n    let toViewModel = false;\n    for (let i = 0, ii = attributes.length; ii > i; ++i) {\n      const $attr = attributes[i];\n      const dest = PLATFORM.camelCase($attr.dest);\n      if ($attr.hasBindingCommand) {\n        const expr = this.exprParser.parse($attr.rawValue, BindingType.BindCommand);\n        letInstructions.push(new LetBindingInstruction(expr, dest));\n      } else if ($attr.rawName === 'to-view-model') {\n        toViewModel = true;\n        (<Element>$el.node).removeAttribute('to-view-model');\n      } else {\n        const expr = this.exprParser.parse($attr.rawValue, BindingType.Interpolation);\n        if (expr === null) {\n          // Should just be a warning, but throw for now\n          throw new Error(`Invalid let binding. String liternal given for attribute: ${$attr.dest}`);\n        }\n        letInstructions.push(new LetBindingInstruction(expr, dest));\n      }\n    }\n    $el.addInstructions([new LetElementInstruction(letInstructions, toViewModel)]);\n    // theoretically there's no need to replace, but to keep it consistent\n    $el.replaceNodeWithMarker();\n  }\n\n  private compileAttribute($attr: IAttributeSymbol): TargetedInstruction {\n      // binding commands get priority over all; they may override default behaviors\n      // it is the responsibility of the implementor to ensure they filter out stuff they shouldn't override\n      if ($attr.isHandledByBindingCommand) {\n        return $attr.command.compile($attr);\n      }\n      // simple path for ref binding\n      const parser = this.exprParser;\n      if ($attr.target === 'ref') {\n        return new RefBindingInstruction(parser.parse($attr.rawValue, BindingType.IsRef));\n      }\n      // simple path for style bindings (TODO: this doesnt work, but we need to use StylePropertyBindingInstruction right?)\n      // if (target === 'style' || target === 'css') {\n      //   const expression = parser.parse(value, BindingType.Interpolation);\n      //   if (expression === null) {\n      //     return null;\n      //   }\n      //   return new StylePropertyBindingInstruction(expression, target);\n      // }\n      // plain custom attribute on any kind of element\n      if ($attr.isCustomAttribute) {\n        if (!$attr.hasBindingCommand) {\n          const expression = parser.parse($attr.rawValue, BindingType.Interpolation);\n          if (expression !== null) {\n            return new InterpolationInstruction(expression, $attr.dest);\n          }\n          if ($attr.isMultiAttrBinding) {\n            return new SetPropertyInstruction($attr.rawValue, $attr.dest);\n          }\n        }\n        // intentional nested block without a statement to ensure the expression variable isn't shadowed\n        // (we're not declaring it at the outer block for better typing without explicit casting)\n        {\n          const expression = parser.parse($attr.rawValue, BindingType.ToViewCommand);\n          switch ($attr.mode) {\n            case BindingMode.oneTime:\n              return new OneTimeBindingInstruction(expression, $attr.dest);\n            case BindingMode.fromView:\n              return new FromViewBindingInstruction(expression, $attr.dest);\n            case BindingMode.twoWay:\n              return new TwoWayBindingInstruction(expression, $attr.dest);\n            case BindingMode.toView:\n            default:\n              return new ToViewBindingInstruction(expression, $attr.dest);\n          }\n        }\n      }\n      // plain attribute on a custom element\n      if ($attr.onCustomElement) {\n        // bindable attribute\n        if ($attr.isElementBindable) {\n          const expression = parser.parse($attr.rawValue, BindingType.Interpolation);\n          if (expression === null) {\n            // no interpolation -> make it a setProperty on the component\n            return new SetPropertyInstruction($attr.rawValue, $attr.dest);\n          }\n          // interpolation -> behave like toView (e.g. foo=\"${someProp}\")\n          return new InterpolationInstruction(expression, $attr.dest);\n        }\n      }\n      {\n        // plain attribute on a normal element\n        const expression = parser.parse($attr.rawValue, BindingType.Interpolation);\n        if (expression === null) {\n          // no interpolation -> do not return an instruction\n          return null;\n        }\n        // interpolation -> behave like toView (e.g. id=\"${someId}\")\n        return new InterpolationInstruction(expression, $attr.dest);\n      }\n  }\n}\n","import { IContainer, Registration } from '@au-test/kernel';\nimport {\n  AttrBindingBehavior,\n  Compose,\n  DebounceBindingBehavior,\n  Else,\n  FromViewBindingBehavior,\n  If,\n  ITemplateCompiler,\n  OneTimeBindingBehavior,\n  Repeat,\n  Replaceable,\n  SanitizeValueConverter,\n  SelfBindingBehavior,\n  SignalBindingBehavior,\n  ThrottleBindingBehavior,\n  ToViewBindingBehavior,\n  TwoWayBindingBehavior,\n  UpdateTriggerBindingBehavior,\n  With\n} from '@au-test/runtime';\nimport {\n  CallBindingCommand,\n  CaptureBindingCommand,\n  DefaultBindingCommand,\n  DelegateBindingCommand,\n  ForBindingCommand,\n  FromViewBindingCommand,\n  OneTimeBindingCommand,\n  ToViewBindingCommand,\n  TriggerBindingCommand,\n  TwoWayBindingCommand\n} from './binding-command';\nimport { ParserRegistration } from './expression-parser';\nimport { TemplateCompiler } from './template-compiler';\n\nconst globalResources: any[] = [\n  Compose,\n  If,\n  Else,\n  Repeat,\n  Replaceable,\n  With,\n  SanitizeValueConverter,\n  AttrBindingBehavior,\n  DebounceBindingBehavior,\n  OneTimeBindingBehavior,\n  ToViewBindingBehavior,\n  FromViewBindingBehavior,\n  SelfBindingBehavior,\n  SignalBindingBehavior,\n  ThrottleBindingBehavior,\n  TwoWayBindingBehavior,\n  UpdateTriggerBindingBehavior\n];\n\nconst defaultBindingLanguage: any[] = [\n  DefaultBindingCommand,\n  OneTimeBindingCommand,\n  ToViewBindingCommand,\n  FromViewBindingCommand,\n  TwoWayBindingCommand,\n  TriggerBindingCommand,\n  DelegateBindingCommand,\n  CaptureBindingCommand,\n  CallBindingCommand,\n  ForBindingCommand\n];\n\nexport const BasicConfiguration = {\n  register(container: IContainer): void {\n    container.register(\n      ParserRegistration,\n      Registration.singleton(ITemplateCompiler, TemplateCompiler),\n      ...globalResources,\n      ...defaultBindingLanguage\n    );\n  }\n};\n"],"names":[],"mappings":"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"}