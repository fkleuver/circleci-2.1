{"version":3,"file":"index.es6.js","sources":["../src/platform.ts","../src/reporter.ts","../src/di.ts"],"sourcesContent":["const camelCaseLookup = {};\nconst kebabCaseLookup = {};\n\nexport const PLATFORM = {\n  // tslint:disable-next-line:no-any\n  global: (function(): any {\n    // Workers donâ€™t have `window`, only `self`\n    // tslint:disable-next-line:no-typeof-undefined\n    if (typeof self !== 'undefined') {\n      return self;\n    }\n\n    // tslint:disable-next-line:no-typeof-undefined\n    if (typeof global !== 'undefined') {\n      return global;\n    }\n\n    // Not all environments allow eval and Function\n    // Use only as a last resort:\n    // tslint:disable-next-line:no-function-constructor-with-string-args\n    return new Function('return this')();\n  })(),\n  emptyArray: Object.freeze([]),\n  emptyObject: Object.freeze({}),\n  /* tslint:disable-next-line:no-empty */\n  noop(): void { },\n  now(): number {\n    return performance.now();\n  },\n\n  camelCase(input: string): string {\n    // benchmark: http://jsben.ch/qIz4Z\n    let value = camelCaseLookup[input];\n    if (value !== undefined) return value;\n    value = '';\n    let first = true;\n    let sep = false;\n    let char: string;\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      char = input.charAt(i);\n      if (char === '-' || char === '.' || char === '_') {\n        sep = true; // skip separators\n      } else {\n        value = value + (first ? char.toLowerCase() : (sep ? char.toUpperCase() : char));\n        sep = false;\n      }\n      first = false;\n    }\n    return camelCaseLookup[input] = value;\n  },\n\n  kebabCase(input: string): string {\n    // benchmark: http://jsben.ch/v7K9T\n    let value = kebabCaseLookup[input];\n    if (value !== undefined) return value;\n    value = '';\n    let first = true;\n    let char: string, lower: string;\n    for (let i = 0, ii = input.length; i < ii; ++i) {\n      char = input.charAt(i);\n      lower = char.toLowerCase();\n      value = value + (first ? lower : (char !== lower ? `-${lower}` : lower));\n      first = false;\n    }\n    return kebabCaseLookup[input] = value;\n  },\n\n  // tslint:disable-next-line:no-any\n  toArray<T = any>(input: ArrayLike<T>): T[] {\n    // benchmark: http://jsben.ch/xjsyF\n    const len = input.length;\n    const arr = Array(len);\n    for (let i = 0; i < len; ++i) {\n        arr[i] = input[i];\n    }\n    return arr;\n  },\n\n  requestAnimationFrame(callback: (time: number) => void): number {\n    return requestAnimationFrame(callback);\n  }\n};\n","export const Reporter = {\n  /* tslint:disable-next-line:no-empty */\n  write(code: number, ...params: any[]): void { },\n  error(code: number, ...params: any[]): Error { return new Error(`Code ${code}`); }\n};\n","// tslint:disable:no-reserved-keywords\nimport { Constructable, IIndexable, Injectable, Primitive } from './interfaces';\nimport { PLATFORM } from './platform';\nimport { Reporter } from './reporter';\n\nexport type ResolveCallback<T = any> = (handler?: IContainer, requestor?: IContainer, resolver?: IResolver) => T;\n\nexport type Key<T> = InterfaceSymbol<T> | Primitive | IIndexable | Function;\n\nexport type InterfaceSymbol<T> = (target: Injectable, property: string, index: number) => any;\n\nexport interface IDefaultableInterfaceSymbol<T> extends InterfaceSymbol<T> {\n  withDefault(configure: (builder: IResolverBuilder<T>) => IResolver): InterfaceSymbol<T>;\n  noDefault(): InterfaceSymbol<T>;\n}\n\nexport interface IResolver<T = any> {\n  resolve(handler: IContainer, requestor: IContainer): T;\n  getFactory?(container: IContainer): IFactory<T> | null;\n}\n\nexport interface IRegistration<T = any> {\n  register(container: IContainer, key?: Key<T>): IResolver<T>;\n}\n\nexport interface IFactory<T = any> {\n  readonly type: Function;\n  registerTransformer(transformer: (instance: T) => T): boolean;\n  construct(container: IContainer, dynamicDependencies?: any[]): T;\n}\n\nexport interface IServiceLocator {\n  has(key: any, searchAncestors: boolean): boolean;\n\n  get<T>(key: Key<T>): T;\n  get<T extends Constructable>(key: T): InstanceType<T>;\n\n  getAll<T>(key: Key<T>): ReadonlyArray<T>;\n  getAll<T extends Constructable>(key: T): ReadonlyArray<InstanceType<T>>;\n}\n\nexport interface IRegistry {\n  register(container: IContainer): void;\n}\n\nexport interface IContainer extends IServiceLocator {\n  register(...params: (IRegistry | Record<string, Partial<IRegistry>>)[]): void;\n  register(registry: IRegistry | Record<string, Partial<IRegistry>>): void;\n\n  registerResolver<T>(key: Key<T>, resolver: IResolver<T>): IResolver<T>;\n  registerResolver<T extends Constructable>(key: T, resolver: IResolver<InstanceType<T>>): IResolver<InstanceType<T>>;\n\n  registerTransformer<T>(key: Key<T>, transformer: (instance: T) => T): boolean;\n  registerTransformer<T extends Constructable>(key: T, transformer: (instance: InstanceType<T>) => T): boolean;\n\n  getResolver<T>(key: Key<T>, autoRegister?: boolean): IResolver<T> | null;\n  getResolver<T extends Constructable>(key: T, autoRegister?: boolean): IResolver<InstanceType<T>> | null;\n\n  getFactory<T extends Constructable>(type: T): IFactory<InstanceType<T>>;\n\n  createChild(): IContainer;\n}\n\nexport interface IResolverBuilder<T> {\n  instance(value: T & IIndexable): IResolver;\n  singleton(value: Constructable<T>): IResolver;\n  transient(value: Constructable<T>): IResolver;\n  callback(value: ResolveCallback<T>): IResolver;\n  aliasTo(destinationKey: Key<T>): IResolver;\n}\n\nif (!('getOwnMetadata' in Reflect)) {\n  (Reflect as any).getOwnMetadata = function(key: string, target: any): any {\n    return target[key];\n  };\n\n  (Reflect as any).metadata = function(key: string, value: any): (target: any) => void {\n    return function(target: any): void {\n      target[key] = value;\n    };\n  };\n}\n\nexport const DI = {\n  createContainer(): IContainer {\n    return new Container();\n  },\n\n  getDesignParamTypes(target: any): any[] {\n    return (Reflect as any).getOwnMetadata('design:paramtypes', target) || PLATFORM.emptyArray;\n  },\n\n  getDependencies(type: Function & { inject?: any }): any[] {\n    let dependencies: any[];\n\n    if (type.inject === undefined) {\n      dependencies = DI.getDesignParamTypes(type);\n    } else {\n      dependencies = [];\n      let ctor = type;\n\n      while (typeof ctor === 'function') {\n        if (ctor.hasOwnProperty('inject')) {\n          dependencies.push(...ctor.inject);\n        }\n\n        ctor = Object.getPrototypeOf(ctor);\n      }\n    }\n\n    return dependencies;\n  },\n\n  createInterface<T = any>(friendlyName?: string): IDefaultableInterfaceSymbol<T> {\n    const Key: any = function(target: Injectable, property: string, index: number): any {\n      const inject = target.inject || (target.inject = []);\n      (Key as any).friendlyName = friendlyName || 'Interface';\n      inject[index] = Key;\n      return target;\n    };\n\n    Key.noDefault = function(): InterfaceSymbol<T> {\n      return Key;\n    };\n\n    Key.withDefault = function(configure: (builder: IResolverBuilder<T>) => IResolver): InterfaceSymbol<T> {\n      Key.withDefault = function(): void {\n        throw Reporter.error(17, Key);\n      };\n\n      Key.register = function(container: IContainer, key?: Key<T>): IResolver<T> {\n        const trueKey = key || Key;\n        return configure({\n          instance(value: T): IResolver {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.instance, value));\n          },\n          singleton(value: Function): IResolver {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.singleton, value));\n          },\n          transient(value: Function): IResolver {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.transient, value));\n          },\n          callback(value: ResolveCallback): IResolver {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.callback, value));\n          },\n          aliasTo(destinationKey: T): IResolver {\n            return container.registerResolver(trueKey, new Resolver(trueKey, ResolverStrategy.alias, destinationKey));\n          },\n        });\n      };\n\n      return Key;\n    };\n\n    return Key;\n  },\n\n  inject(...dependencies: any[]): (target: any, property?: string, descriptor?: PropertyDescriptor | number) => any {\n    return function(target: any, key?, descriptor?) {\n      if (typeof descriptor === 'number') { // It's a parameter decorator.\n        if (!target.hasOwnProperty('inject')) {\n          target.inject = DI.getDesignParamTypes(target).slice();\n        }\n\n        if (dependencies.length === 1) {\n          target.inject[descriptor] = dependencies[0];\n        }\n      } else if (key) { // It's a property decorator. Not supported by the container without plugins.\n        const actualTarget = target.constructor;\n        const inject = actualTarget.inject || (actualTarget.inject = {});\n        inject[key] = dependencies[0];\n      } else if (descriptor) { // It's a function decorator (not a Class constructor)\n        const fn = descriptor.value;\n        fn.inject = dependencies;\n      } else { // It's a class decorator.\n        if (!dependencies || dependencies.length === 0) {\n          target.inject = DI.getDesignParamTypes(target).slice();\n        } else {\n          target.inject = dependencies;\n        }\n      }\n    };\n  }\n};\n\nexport const IContainer = DI.createInterface<IContainer>().noDefault();\nexport const IServiceLocator = IContainer as InterfaceSymbol<IServiceLocator>;\n\nfunction createResolver(\n  getter: (key: any, handler: IContainer, requestor: IContainer) => any\n): (key: any) => ReturnType<typeof DI.inject> {\n  return function(key: any): ReturnType<typeof DI.inject> {\n    const Key = function Key(target: Injectable, property?: string, descriptor?: PropertyDescriptor | number): void {\n      return DI.inject(Key)(target, property, descriptor);\n    };\n\n    (Key as any).resolve = function(handler: IContainer, requestor: IContainer): any {\n      return getter(key, handler, requestor);\n    };\n\n    return Key;\n  };\n}\n\nexport const inject = DI.inject;\n\nexport const all = createResolver((key: any, handler: IContainer, requestor: IContainer) => requestor.getAll(key));\n\nexport const lazy = createResolver((key: any, handler: IContainer, requestor: IContainer) =>  {\n  let instance: any = null; // cache locally so that lazy always returns the same instance once resolved\n  return () => {\n    if (instance === null) {\n      instance = requestor.get(key);\n    }\n\n    return instance;\n  };\n});\n\nexport const optional = createResolver((key: any, handler: IContainer, requestor: IContainer) =>  {\n  if (requestor.has(key, true)) {\n    return requestor.get(key);\n  } else {\n    return null;\n  }\n});\n\n/*@internal*/\nexport const enum ResolverStrategy {\n  instance = 0,\n  singleton = 1,\n  transient = 2,\n  callback = 3,\n  array = 4,\n  alias = 5\n}\n\n/*@internal*/\nexport class Resolver implements IResolver, IRegistration {\n  constructor(public key: any, public strategy: ResolverStrategy, public state: any) {}\n\n  public register(container: IContainer, key?: any): IResolver {\n    return container.registerResolver(key || this.key, this);\n  }\n\n  public resolve(handler: IContainer, requestor: IContainer): any {\n    switch (this.strategy) {\n      case ResolverStrategy.instance:\n        return this.state;\n      case ResolverStrategy.singleton:\n        this.strategy = ResolverStrategy.instance;\n        return this.state = handler.getFactory(this.state).construct(handler);\n      case ResolverStrategy.transient:\n        // Always create transients from the requesting container\n        return handler.getFactory(this.state).construct(requestor);\n      case ResolverStrategy.callback:\n        return (this.state as ResolveCallback)(handler, requestor, this);\n      case ResolverStrategy.array:\n        return this.state[0].resolve(handler, requestor);\n      case ResolverStrategy.alias:\n        return handler.get(this.state);\n      default:\n        throw Reporter.error(6, this.strategy);\n    }\n  }\n\n  public getFactory(container: IContainer): IFactory | null {\n    switch (this.strategy) {\n      case ResolverStrategy.singleton:\n      case ResolverStrategy.transient:\n        return container.getFactory(this.state);\n      default:\n        return null;\n    }\n  }\n}\n\n/*@internal*/\nexport interface IInvoker {\n  invoke(container: IContainer, fn: Function, dependencies: any[]): any;\n  invokeWithDynamicDependencies(\n    container: IContainer,\n    fn: Function,\n    staticDependencies: any[],\n    dynamicDependencies: any[]\n  ): any;\n}\n\n/*@internal*/\nexport class Factory implements IFactory {\n  private transformers: ((instance: any) => any)[] | null = null;\n\n  constructor(public type: Function, private invoker: IInvoker, private dependencies: any[]) { }\n\n  public static create(type: Function): IFactory {\n    const dependencies = DI.getDependencies(type);\n    const invoker = classInvokers[dependencies.length] || fallbackInvoker;\n    return new Factory(type, invoker, dependencies);\n  }\n\n  public construct(container: IContainer, dynamicDependencies?: any[]): any {\n    const transformers = this.transformers;\n    let instance = dynamicDependencies !== undefined\n      ? this.invoker.invokeWithDynamicDependencies(container, this.type, this.dependencies, dynamicDependencies)\n      : this.invoker.invoke(container, this.type, this.dependencies);\n\n    if (transformers === null) {\n      return instance;\n    }\n\n    for (let i = 0, ii = transformers.length; i < ii; ++i) {\n      instance = transformers[i](instance);\n    }\n\n    return instance;\n  }\n\n  public registerTransformer(transformer: (instance: any) => any): boolean {\n    if (this.transformers === null) {\n      this.transformers = [];\n    }\n\n    this.transformers.push(transformer);\n    return true;\n  }\n}\n\n/*@internal*/\nexport interface IContainerConfiguration {\n  factories?: Map<Function, IFactory>;\n}\n\nconst containerResolver: IResolver = {\n  resolve(handler: IContainer, requestor: IContainer): IContainer {\n    return requestor;\n  }\n};\n\nfunction isRegistry(obj: IRegistry | Record<string, IRegistry>): obj is IRegistry {\n  return typeof obj.register === 'function';\n}\n\n/*@internal*/\nexport class Container implements IContainer {\n  private parent: Container | null = null;\n  private resolvers: Map<any, IResolver> = new Map<any, IResolver>();\n  private factories: Map<Function, IFactory>;\n  private configuration: IContainerConfiguration;\n\n  constructor(configuration: IContainerConfiguration = {}) {\n    this.configuration = configuration;\n    this.factories = configuration.factories || (configuration.factories = new Map());\n    this.resolvers.set(IContainer, containerResolver);\n  }\n\n  public register(registry: (IRegistry | Record<string, Partial<IRegistry>>)): void;\n  public register(...params: (IRegistry | Record<string, Partial<IRegistry>>)[]): void {\n    for (let i = 0, ii = params.length; i < ii; ++i) {\n      const current = params[i] as IRegistry | Record<string, IRegistry>;\n      if (isRegistry(current)) {\n        current.register(this);\n      } else {\n        const keys = Object.keys(current);\n        for (let j = 0, jj = keys.length; j < jj; ++j) {\n          const value = current[keys[j]];\n          // note: we could remove this if-branch and call this.register directly\n          // - the extra check is just a perf tweak to create fewer unnecessary arrays by the spread operator\n          if (isRegistry(value)) {\n            value.register(this);\n          } else {\n            this.register(value);\n          }\n        }\n      }\n    }\n  }\n\n  public registerResolver(key: any, resolver: IResolver): IResolver {\n    validateKey(key);\n\n    const resolvers = this.resolvers;\n    const result = resolvers.get(key);\n\n    if (result === undefined) {\n      resolvers.set(key, resolver);\n    } else if (result instanceof Resolver && (result as Resolver).strategy === ResolverStrategy.array) {\n      (result as Resolver).state.push(resolver);\n    } else {\n      resolvers.set(key, new Resolver(key, ResolverStrategy.array, [result, resolver]));\n    }\n\n    return resolver;\n  }\n\n  public registerTransformer(key: any, transformer: (instance: any) => any): boolean {\n    const resolver = this.getResolver(key);\n\n    if (resolver === null) {\n      return false;\n    }\n\n    if (resolver.getFactory) {\n      const handler = resolver.getFactory(this);\n\n      if (handler === null) {\n        return false;\n      }\n\n      return handler.registerTransformer(transformer);\n    }\n\n    return false;\n  }\n\n  public getResolver(key: any, autoRegister = true): IResolver | null {\n    validateKey(key);\n\n    if (key.resolve) {\n      return key;\n    }\n\n    let current: Container = this;\n\n    while (current !== null) {\n      const resolver = current.resolvers.get(key);\n\n      if (resolver === undefined) {\n        if (current.parent === null) {\n          return autoRegister ? this.jitRegister(key, current) : null;\n        }\n\n        current = current.parent;\n      } else {\n        return resolver;\n      }\n    }\n\n    return null;\n  }\n\n  public has(key: any, searchAncestors: boolean = false): boolean {\n    return this.resolvers.has(key)\n      ? true\n      : searchAncestors && this.parent !== null\n      ? this.parent.has(key, true)\n      : false;\n  }\n\n  public get(key: any): any {\n    validateKey(key);\n\n    if (key.resolve) {\n      return key.resolve(this, this);\n    }\n\n    let current: Container = this;\n\n    while (current !== null) {\n      const resolver = current.resolvers.get(key);\n\n      if (resolver === undefined) {\n        if (current.parent === null) {\n          return this.jitRegister(key, current).resolve(current, this);\n        }\n\n        current = current.parent;\n      } else {\n        return resolver.resolve(current, this);\n      }\n    }\n  }\n\n  public getAll(key: any): ReadonlyArray<any> {\n    validateKey(key);\n\n    let current: Container | null = this;\n\n    while (current !== null) {\n      const resolver = current.resolvers.get(key);\n\n      if (resolver === undefined) {\n        if (this.parent === null) {\n          return PLATFORM.emptyArray;\n        }\n\n        current = current.parent;\n      } else {\n        return buildAllResponse(resolver, current, this);\n      }\n    }\n\n    return PLATFORM.emptyArray;\n  }\n\n  public getFactory(type: Function): IFactory {\n    let factory = this.factories.get(type);\n\n    if (factory === undefined) {\n      factory = Factory.create(type);\n      this.factories.set(type, factory);\n    }\n\n    return factory;\n  }\n\n  public createChild(): IContainer {\n    const child = new Container(this.configuration);\n    child.parent = this;\n    return child;\n  }\n\n  private jitRegister(keyAsValue: any, handler: Container): IResolver {\n    if (keyAsValue.register) {\n      return keyAsValue.register(handler, keyAsValue) || null;\n    }\n\n    const resolver = new Resolver(keyAsValue, ResolverStrategy.singleton, keyAsValue);\n    handler.resolvers.set(keyAsValue, resolver);\n    return resolver;\n  }\n}\n\nexport const Registration = {\n  instance(key: any, value: any): IRegistration {\n    return new Resolver(key, ResolverStrategy.instance, value);\n  },\n\n  singleton(key: any, value: Function): IRegistration {\n    return new Resolver(key, ResolverStrategy.singleton, value);\n  },\n\n  transient(key: any, value: Function): IRegistration {\n    return new Resolver(key, ResolverStrategy.transient, value);\n  },\n\n  callback(key: any, callback: ResolveCallback): IRegistration {\n    return new Resolver(key, ResolverStrategy.callback, callback);\n  },\n\n  alias(originalKey: any, aliasKey: any): IRegistration {\n    return new Resolver(aliasKey, ResolverStrategy.alias, originalKey);\n  },\n\n  interpret(interpreterKey: any, ...rest: any[]): IRegistry {\n    return {\n      register(container: IContainer): void {\n        const resolver = container.getResolver<IRegistry>(interpreterKey);\n\n        if (resolver !== null) {\n          let registry: IRegistry | null =  null;\n\n          if (resolver.getFactory) {\n            const factory = resolver.getFactory(container);\n\n            if (factory !== null) {\n              registry = factory.construct(container, rest);\n            }\n          } else {\n            registry = resolver.resolve(container, container);\n          }\n\n          if (registry !== null) {\n            registry.register(container);\n          }\n        }\n      }\n    };\n  }\n};\n\n/*@internal*/\nexport function validateKey(key: any): void {\n  // note: design:paramTypes which will default to Object if the param types cannot be statically analyzed by tsc\n  // this check is intended to properly report on that problem - under no circumstance should Object be a valid key anyway\n  if (key === null || key === undefined || key === Object) {\n    throw Reporter.error(5);\n  }\n}\n\nfunction buildAllResponse(resolver: IResolver, handler: IContainer, requestor: IContainer): any[] {\n  if (resolver instanceof Resolver && resolver.strategy === ResolverStrategy.array) {\n    const state = resolver.state;\n    let i = state.length;\n    const results = new Array(i);\n\n    while (i--) {\n      results[i] = state[i].get(handler, requestor);\n    }\n\n    return results;\n  }\n\n  return [resolver.resolve(handler, requestor)];\n}\n\n/*@internal*/\nexport const classInvokers: IInvoker[] = [\n  {\n    invoke<T extends Constructable<K>, K>(container: IContainer, Type: T): K {\n      return new Type();\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T extends Constructable<K>, K>(container: IContainer, Type: T, deps: any[]): K {\n      return new Type(container.get(deps[0]));\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T extends Constructable<K>, K>(container: IContainer, Type: T, deps: any[]): K {\n      return new Type(container.get(deps[0]), container.get(deps[1]));\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T extends Constructable<K>, K>(container: IContainer, Type: T, deps: any[]): K {\n      return new Type(container.get(deps[0]), container.get(deps[1]), container.get(deps[2]));\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T extends Constructable<K>, K>(container: IContainer, Type: T, deps: any[]): K {\n      return new Type(\n        container.get(deps[0]),\n        container.get(deps[1]),\n        container.get(deps[2]),\n        container.get(deps[3])\n      );\n    },\n    invokeWithDynamicDependencies\n  },\n  {\n    invoke<T extends Constructable<K>, K>(container: IContainer, Type: T, deps: any[]): K {\n      return new Type(\n        container.get(deps[0]),\n        container.get(deps[1]),\n        container.get(deps[2]),\n        container.get(deps[3]),\n        container.get(deps[4])\n      );\n    },\n    invokeWithDynamicDependencies\n  }\n];\n\n/*@internal*/\nexport const fallbackInvoker: IInvoker = {\n  invoke: invokeWithDynamicDependencies as any,\n  invokeWithDynamicDependencies\n};\n\n/*@internal*/\nexport function invokeWithDynamicDependencies<T extends Constructable<K>, K>(\n  container: IContainer,\n  Type: T,\n  staticDependencies: any[],\n  dynamicDependencies: any[]\n): K {\n  let i = staticDependencies.length;\n  let args = new Array(i);\n  let lookup;\n\n  while (i--) {\n    lookup = staticDependencies[i];\n\n    if (lookup === null || lookup === undefined) {\n      throw Reporter.error(7, `Index ${i}.`);\n    } else {\n      args[i] = container.get(lookup);\n    }\n  }\n\n  if (dynamicDependencies !== undefined) {\n    args = args.concat(dynamicDependencies);\n  }\n\n  return Reflect.construct(Type, args);\n}\n"],"names":[],"mappings":"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"}